// @generated by pegen.py from ./Grammar/python.gram
#include "pegen.h"
static const int n_keyword_lists = 15;
static KeywordToken *reserved_keywords[] = {
    NULL,
    NULL,
    (KeywordToken[]) {
        {"if", 510},
        {"in", 518},
        {"is", 526},
        {"as", 531},
        {"or", 532},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"del", 503},
        {"try", 511},
        {"for", 517},
        {"def", 522},
        {"not", 525},
        {"and", 533},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"pass", 502},
        {"from", 514},
        {"elif", 515},
        {"else", 516},
        {"with", 519},
        {"True", 527},
        {"None", 529},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"raise", 501},
        {"yield", 504},
        {"break", 506},
        {"while", 512},
        {"class", 523},
        {"False", 528},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"return", 500},
        {"assert", 505},
        {"global", 508},
        {"import", 513},
        {"except", 520},
        {"lambda", 524},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"finally", 521},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"continue", 507},
        {"nonlocal", 509},
        {NULL, -1},
    },
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (KeywordToken[]) {
        {"__new_parser__", 530},
        {NULL, -1},
    },
};
#define file_type 1000
#define interactive_type 1001
#define eval_type 1002
#define fstring_type 1003
#define statements_type 1004
#define statement_type 1005
#define statement_newline_type 1006
#define simple_stmt_type 1007
#define small_stmt_type 1008
#define compound_stmt_type 1009
#define assignment_type 1010
#define augassign_type 1011
#define global_stmt_type 1012
#define nonlocal_stmt_type 1013
#define yield_stmt_type 1014
#define assert_stmt_type 1015
#define del_stmt_type 1016
#define import_stmt_type 1017
#define import_name_type 1018
#define import_from_type 1019
#define import_from_targets_type 1020
#define import_from_as_names_type 1021
#define import_from_as_name_type 1022
#define dotted_as_names_type 1023
#define dotted_as_name_type 1024
#define dotted_name_type 1025  // Left-recursive
#define if_stmt_type 1026
#define elif_stmt_type 1027
#define else_block_type 1028
#define while_stmt_type 1029
#define for_stmt_type 1030
#define with_stmt_type 1031
#define with_item_type 1032
#define try_stmt_type 1033
#define except_block_type 1034
#define finally_block_type 1035
#define return_stmt_type 1036
#define raise_stmt_type 1037
#define function_def_type 1038
#define function_def_raw_type 1039
#define params_type 1040
#define parameters_type 1041
#define slash_without_default_type 1042
#define slash_with_default_type 1043
#define star_etc_type 1044
#define name_with_optional_default_type 1045
#define names_with_default_type 1046
#define name_with_default_type 1047
#define plain_names_type 1048
#define plain_name_type 1049
#define kwds_type 1050
#define annotation_type 1051
#define decorators_type 1052
#define class_def_type 1053
#define class_def_raw_type 1054
#define block_type 1055
#define expressions_list_type 1056
#define star_expressions_type 1057
#define star_expression_type 1058
#define star_named_expressions_type 1059
#define star_named_expression_type 1060
#define named_expression_type 1061
#define annotated_rhs_type 1062
#define expressions_type 1063
#define expression_type 1064
#define lambdef_type 1065
#define lambda_parameters_type 1066
#define lambda_slash_without_default_type 1067
#define lambda_slash_with_default_type 1068
#define lambda_star_etc_type 1069
#define lambda_name_with_optional_default_type 1070
#define lambda_names_with_default_type 1071
#define lambda_name_with_default_type 1072
#define lambda_plain_names_type 1073
#define lambda_plain_name_type 1074
#define lambda_kwds_type 1075
#define disjunction_type 1076
#define conjunction_type 1077
#define inversion_type 1078
#define comparison_type 1079
#define compare_op_bitwise_or_pair_type 1080
#define eq_bitwise_or_type 1081
#define noteq_bitwise_or_type 1082
#define lte_bitwise_or_type 1083
#define lt_bitwise_or_type 1084
#define gte_bitwise_or_type 1085
#define gt_bitwise_or_type 1086
#define notin_bitwise_or_type 1087
#define in_bitwise_or_type 1088
#define isnot_bitwise_or_type 1089
#define is_bitwise_or_type 1090
#define bitwise_or_type 1091  // Left-recursive
#define bitwise_xor_type 1092  // Left-recursive
#define bitwise_and_type 1093  // Left-recursive
#define shift_expr_type 1094  // Left-recursive
#define sum_type 1095  // Left-recursive
#define term_type 1096  // Left-recursive
#define factor_type 1097
#define power_type 1098
#define await_primary_type 1099
#define primary_type 1100  // Left-recursive
#define slices_type 1101
#define slice_type 1102
#define atom_type 1103
#define strings_type 1104
#define list_type 1105
#define listcomp_type 1106
#define tuple_type 1107
#define group_type 1108
#define genexp_type 1109
#define set_type 1110
#define setcomp_type 1111
#define dict_type 1112
#define dictcomp_type 1113
#define kvpairs_type 1114
#define kvpair_type 1115
#define for_if_clauses_type 1116
#define yield_expr_type 1117
#define arguments_type 1118
#define args_type 1119
#define kwargs_type 1120
#define starred_expression_type 1121
#define kwarg_or_starred_type 1122
#define kwarg_or_double_starred_type 1123
#define star_targets_type 1124
#define star_targets_seq_type 1125
#define star_target_type 1126
#define star_atom_type 1127
#define inside_paren_ann_assign_target_type 1128
#define ann_assign_subscript_attribute_target_type 1129
#define del_targets_type 1130
#define del_target_type 1131
#define del_t_atom_type 1132
#define targets_type 1133
#define target_type 1134
#define t_primary_type 1135  // Left-recursive
#define t_lookahead_type 1136
#define t_atom_type 1137
#define incorrect_arguments_type 1138
#define invalid_named_expression_type 1139
#define invalid_assignment_type 1140
#define invalid_block_type 1141
#define invalid_comprehension_type 1142
#define invalid_parameters_type 1143
#define _loop0_1_type 1144
#define _loop1_2_type 1145
#define _loop0_4_type 1146
#define _gather_3_type 1147
#define _tmp_5_type 1148
#define _tmp_6_type 1149
#define _tmp_7_type 1150
#define _tmp_8_type 1151
#define _tmp_9_type 1152
#define _tmp_10_type 1153
#define _tmp_11_type 1154
#define _tmp_12_type 1155
#define _loop1_13_type 1156
#define _tmp_14_type 1157
#define _tmp_15_type 1158
#define _loop0_17_type 1159
#define _gather_16_type 1160
#define _loop0_19_type 1161
#define _gather_18_type 1162
#define _tmp_20_type 1163
#define _loop0_21_type 1164
#define _loop1_22_type 1165
#define _loop0_24_type 1166
#define _gather_23_type 1167
#define _tmp_25_type 1168
#define _loop0_27_type 1169
#define _gather_26_type 1170
#define _tmp_28_type 1171
#define _loop0_30_type 1172
#define _gather_29_type 1173
#define _loop0_32_type 1174
#define _gather_31_type 1175
#define _tmp_33_type 1176
#define _loop1_34_type 1177
#define _tmp_35_type 1178
#define _tmp_36_type 1179
#define _tmp_37_type 1180
#define _tmp_38_type 1181
#define _tmp_39_type 1182
#define _tmp_40_type 1183
#define _tmp_41_type 1184
#define _tmp_42_type 1185
#define _tmp_43_type 1186
#define _tmp_44_type 1187
#define _tmp_45_type 1188
#define _tmp_46_type 1189
#define _loop0_47_type 1190
#define _tmp_48_type 1191
#define _loop1_49_type 1192
#define _tmp_50_type 1193
#define _tmp_51_type 1194
#define _loop0_53_type 1195
#define _gather_52_type 1196
#define _loop0_55_type 1197
#define _gather_54_type 1198
#define _tmp_56_type 1199
#define _loop1_57_type 1200
#define _tmp_58_type 1201
#define _loop0_60_type 1202
#define _gather_59_type 1203
#define _loop1_61_type 1204
#define _loop0_63_type 1205
#define _gather_62_type 1206
#define _loop1_64_type 1207
#define _tmp_65_type 1208
#define _tmp_66_type 1209
#define _tmp_67_type 1210
#define _tmp_68_type 1211
#define _tmp_69_type 1212
#define _tmp_70_type 1213
#define _tmp_71_type 1214
#define _tmp_72_type 1215
#define _tmp_73_type 1216
#define _loop0_74_type 1217
#define _tmp_75_type 1218
#define _loop1_76_type 1219
#define _tmp_77_type 1220
#define _tmp_78_type 1221
#define _loop0_80_type 1222
#define _gather_79_type 1223
#define _loop0_82_type 1224
#define _gather_81_type 1225
#define _loop1_83_type 1226
#define _loop1_84_type 1227
#define _loop1_85_type 1228
#define _loop0_87_type 1229
#define _gather_86_type 1230
#define _tmp_88_type 1231
#define _tmp_89_type 1232
#define _tmp_90_type 1233
#define _tmp_91_type 1234
#define _loop1_92_type 1235
#define _tmp_93_type 1236
#define _tmp_94_type 1237
#define _loop0_96_type 1238
#define _gather_95_type 1239
#define _loop1_97_type 1240
#define _tmp_98_type 1241
#define _tmp_99_type 1242
#define _loop0_101_type 1243
#define _gather_100_type 1244
#define _loop0_103_type 1245
#define _gather_102_type 1246
#define _loop0_105_type 1247
#define _gather_104_type 1248
#define _loop0_107_type 1249
#define _gather_106_type 1250
#define _loop0_108_type 1251
#define _loop0_110_type 1252
#define _gather_109_type 1253
#define _tmp_111_type 1254
#define _loop0_113_type 1255
#define _gather_112_type 1256
#define _loop0_115_type 1257
#define _gather_114_type 1258
#define _tmp_116_type 1259
#define _tmp_117_type 1260
#define _tmp_118_type 1261
#define _tmp_119_type 1262
#define _tmp_120_type 1263
#define _tmp_121_type 1264
#define _tmp_122_type 1265
#define _tmp_123_type 1266
#define _tmp_124_type 1267
#define _tmp_125_type 1268
#define _tmp_126_type 1269
#define _tmp_127_type 1270
#define _tmp_128_type 1271
#define _tmp_129_type 1272
#define _tmp_130_type 1273
#define _tmp_131_type 1274
#define _tmp_132_type 1275
#define _tmp_133_type 1276
#define _tmp_134_type 1277
#define _loop0_135_type 1278
#define _tmp_136_type 1279

static mod_ty file_rule(Parser *p);
static mod_ty interactive_rule(Parser *p);
static mod_ty eval_rule(Parser *p);
static expr_ty fstring_rule(Parser *p);
static asdl_seq* statements_rule(Parser *p);
static asdl_seq* statement_rule(Parser *p);
static asdl_seq* statement_newline_rule(Parser *p);
static asdl_seq* simple_stmt_rule(Parser *p);
static stmt_ty small_stmt_rule(Parser *p);
static stmt_ty compound_stmt_rule(Parser *p);
static void *assignment_rule(Parser *p);
static AugOperator* augassign_rule(Parser *p);
static stmt_ty global_stmt_rule(Parser *p);
static stmt_ty nonlocal_stmt_rule(Parser *p);
static stmt_ty yield_stmt_rule(Parser *p);
static stmt_ty assert_stmt_rule(Parser *p);
static stmt_ty del_stmt_rule(Parser *p);
static stmt_ty import_stmt_rule(Parser *p);
static stmt_ty import_name_rule(Parser *p);
static stmt_ty import_from_rule(Parser *p);
static asdl_seq* import_from_targets_rule(Parser *p);
static asdl_seq* import_from_as_names_rule(Parser *p);
static alias_ty import_from_as_name_rule(Parser *p);
static asdl_seq* dotted_as_names_rule(Parser *p);
static alias_ty dotted_as_name_rule(Parser *p);
static expr_ty dotted_name_rule(Parser *p);
static stmt_ty if_stmt_rule(Parser *p);
static stmt_ty elif_stmt_rule(Parser *p);
static asdl_seq* else_block_rule(Parser *p);
static stmt_ty while_stmt_rule(Parser *p);
static stmt_ty for_stmt_rule(Parser *p);
static stmt_ty with_stmt_rule(Parser *p);
static withitem_ty with_item_rule(Parser *p);
static stmt_ty try_stmt_rule(Parser *p);
static excepthandler_ty except_block_rule(Parser *p);
static asdl_seq* finally_block_rule(Parser *p);
static stmt_ty return_stmt_rule(Parser *p);
static stmt_ty raise_stmt_rule(Parser *p);
static stmt_ty function_def_rule(Parser *p);
static stmt_ty function_def_raw_rule(Parser *p);
static arguments_ty params_rule(Parser *p);
static arguments_ty parameters_rule(Parser *p);
static asdl_seq* slash_without_default_rule(Parser *p);
static SlashWithDefault* slash_with_default_rule(Parser *p);
static StarEtc* star_etc_rule(Parser *p);
static NameDefaultPair* name_with_optional_default_rule(Parser *p);
static asdl_seq* names_with_default_rule(Parser *p);
static NameDefaultPair* name_with_default_rule(Parser *p);
static asdl_seq* plain_names_rule(Parser *p);
static arg_ty plain_name_rule(Parser *p);
static arg_ty kwds_rule(Parser *p);
static expr_ty annotation_rule(Parser *p);
static asdl_seq* decorators_rule(Parser *p);
static stmt_ty class_def_rule(Parser *p);
static stmt_ty class_def_raw_rule(Parser *p);
static asdl_seq* block_rule(Parser *p);
static asdl_seq* expressions_list_rule(Parser *p);
static expr_ty star_expressions_rule(Parser *p);
static expr_ty star_expression_rule(Parser *p);
static asdl_seq* star_named_expressions_rule(Parser *p);
static expr_ty star_named_expression_rule(Parser *p);
static expr_ty named_expression_rule(Parser *p);
static expr_ty annotated_rhs_rule(Parser *p);
static expr_ty expressions_rule(Parser *p);
static expr_ty expression_rule(Parser *p);
static expr_ty lambdef_rule(Parser *p);
static arguments_ty lambda_parameters_rule(Parser *p);
static asdl_seq* lambda_slash_without_default_rule(Parser *p);
static SlashWithDefault* lambda_slash_with_default_rule(Parser *p);
static StarEtc* lambda_star_etc_rule(Parser *p);
static NameDefaultPair* lambda_name_with_optional_default_rule(Parser *p);
static asdl_seq* lambda_names_with_default_rule(Parser *p);
static NameDefaultPair* lambda_name_with_default_rule(Parser *p);
static asdl_seq* lambda_plain_names_rule(Parser *p);
static arg_ty lambda_plain_name_rule(Parser *p);
static arg_ty lambda_kwds_rule(Parser *p);
static expr_ty disjunction_rule(Parser *p);
static expr_ty conjunction_rule(Parser *p);
static expr_ty inversion_rule(Parser *p);
static expr_ty comparison_rule(Parser *p);
static CmpopExprPair* compare_op_bitwise_or_pair_rule(Parser *p);
static CmpopExprPair* eq_bitwise_or_rule(Parser *p);
static CmpopExprPair* noteq_bitwise_or_rule(Parser *p);
static CmpopExprPair* lte_bitwise_or_rule(Parser *p);
static CmpopExprPair* lt_bitwise_or_rule(Parser *p);
static CmpopExprPair* gte_bitwise_or_rule(Parser *p);
static CmpopExprPair* gt_bitwise_or_rule(Parser *p);
static CmpopExprPair* notin_bitwise_or_rule(Parser *p);
static CmpopExprPair* in_bitwise_or_rule(Parser *p);
static CmpopExprPair* isnot_bitwise_or_rule(Parser *p);
static CmpopExprPair* is_bitwise_or_rule(Parser *p);
static expr_ty bitwise_or_rule(Parser *p);
static expr_ty bitwise_xor_rule(Parser *p);
static expr_ty bitwise_and_rule(Parser *p);
static expr_ty shift_expr_rule(Parser *p);
static expr_ty sum_rule(Parser *p);
static expr_ty term_rule(Parser *p);
static expr_ty factor_rule(Parser *p);
static expr_ty power_rule(Parser *p);
static expr_ty await_primary_rule(Parser *p);
static expr_ty primary_rule(Parser *p);
static expr_ty slices_rule(Parser *p);
static expr_ty slice_rule(Parser *p);
static expr_ty atom_rule(Parser *p);
static expr_ty strings_rule(Parser *p);
static expr_ty list_rule(Parser *p);
static expr_ty listcomp_rule(Parser *p);
static expr_ty tuple_rule(Parser *p);
static expr_ty group_rule(Parser *p);
static expr_ty genexp_rule(Parser *p);
static expr_ty set_rule(Parser *p);
static expr_ty setcomp_rule(Parser *p);
static expr_ty dict_rule(Parser *p);
static expr_ty dictcomp_rule(Parser *p);
static asdl_seq* kvpairs_rule(Parser *p);
static KeyValuePair* kvpair_rule(Parser *p);
static asdl_seq* for_if_clauses_rule(Parser *p);
static expr_ty yield_expr_rule(Parser *p);
static expr_ty arguments_rule(Parser *p);
static expr_ty args_rule(Parser *p);
static asdl_seq* kwargs_rule(Parser *p);
static expr_ty starred_expression_rule(Parser *p);
static KeywordOrStarred* kwarg_or_starred_rule(Parser *p);
static KeywordOrStarred* kwarg_or_double_starred_rule(Parser *p);
static expr_ty star_targets_rule(Parser *p);
static asdl_seq* star_targets_seq_rule(Parser *p);
static expr_ty star_target_rule(Parser *p);
static expr_ty star_atom_rule(Parser *p);
static expr_ty inside_paren_ann_assign_target_rule(Parser *p);
static expr_ty ann_assign_subscript_attribute_target_rule(Parser *p);
static asdl_seq* del_targets_rule(Parser *p);
static expr_ty del_target_rule(Parser *p);
static expr_ty del_t_atom_rule(Parser *p);
static asdl_seq* targets_rule(Parser *p);
static expr_ty target_rule(Parser *p);
static expr_ty t_primary_rule(Parser *p);
static void *t_lookahead_rule(Parser *p);
static expr_ty t_atom_rule(Parser *p);
static void *incorrect_arguments_rule(Parser *p);
static void *invalid_named_expression_rule(Parser *p);
static void *invalid_assignment_rule(Parser *p);
static void *invalid_block_rule(Parser *p);
static void *invalid_comprehension_rule(Parser *p);
static void *invalid_parameters_rule(Parser *p);
static asdl_seq *_loop0_1_rule(Parser *p);
static asdl_seq *_loop1_2_rule(Parser *p);
static asdl_seq *_loop0_4_rule(Parser *p);
static asdl_seq *_gather_3_rule(Parser *p);
static void *_tmp_5_rule(Parser *p);
static void *_tmp_6_rule(Parser *p);
static void *_tmp_7_rule(Parser *p);
static void *_tmp_8_rule(Parser *p);
static void *_tmp_9_rule(Parser *p);
static void *_tmp_10_rule(Parser *p);
static void *_tmp_11_rule(Parser *p);
static void *_tmp_12_rule(Parser *p);
static asdl_seq *_loop1_13_rule(Parser *p);
static void *_tmp_14_rule(Parser *p);
static void *_tmp_15_rule(Parser *p);
static asdl_seq *_loop0_17_rule(Parser *p);
static asdl_seq *_gather_16_rule(Parser *p);
static asdl_seq *_loop0_19_rule(Parser *p);
static asdl_seq *_gather_18_rule(Parser *p);
static void *_tmp_20_rule(Parser *p);
static asdl_seq *_loop0_21_rule(Parser *p);
static asdl_seq *_loop1_22_rule(Parser *p);
static asdl_seq *_loop0_24_rule(Parser *p);
static asdl_seq *_gather_23_rule(Parser *p);
static void *_tmp_25_rule(Parser *p);
static asdl_seq *_loop0_27_rule(Parser *p);
static asdl_seq *_gather_26_rule(Parser *p);
static void *_tmp_28_rule(Parser *p);
static asdl_seq *_loop0_30_rule(Parser *p);
static asdl_seq *_gather_29_rule(Parser *p);
static asdl_seq *_loop0_32_rule(Parser *p);
static asdl_seq *_gather_31_rule(Parser *p);
static void *_tmp_33_rule(Parser *p);
static asdl_seq *_loop1_34_rule(Parser *p);
static void *_tmp_35_rule(Parser *p);
static void *_tmp_36_rule(Parser *p);
static void *_tmp_37_rule(Parser *p);
static void *_tmp_38_rule(Parser *p);
static void *_tmp_39_rule(Parser *p);
static void *_tmp_40_rule(Parser *p);
static void *_tmp_41_rule(Parser *p);
static void *_tmp_42_rule(Parser *p);
static void *_tmp_43_rule(Parser *p);
static void *_tmp_44_rule(Parser *p);
static void *_tmp_45_rule(Parser *p);
static void *_tmp_46_rule(Parser *p);
static asdl_seq *_loop0_47_rule(Parser *p);
static void *_tmp_48_rule(Parser *p);
static asdl_seq *_loop1_49_rule(Parser *p);
static void *_tmp_50_rule(Parser *p);
static void *_tmp_51_rule(Parser *p);
static asdl_seq *_loop0_53_rule(Parser *p);
static asdl_seq *_gather_52_rule(Parser *p);
static asdl_seq *_loop0_55_rule(Parser *p);
static asdl_seq *_gather_54_rule(Parser *p);
static void *_tmp_56_rule(Parser *p);
static asdl_seq *_loop1_57_rule(Parser *p);
static void *_tmp_58_rule(Parser *p);
static asdl_seq *_loop0_60_rule(Parser *p);
static asdl_seq *_gather_59_rule(Parser *p);
static asdl_seq *_loop1_61_rule(Parser *p);
static asdl_seq *_loop0_63_rule(Parser *p);
static asdl_seq *_gather_62_rule(Parser *p);
static asdl_seq *_loop1_64_rule(Parser *p);
static void *_tmp_65_rule(Parser *p);
static void *_tmp_66_rule(Parser *p);
static void *_tmp_67_rule(Parser *p);
static void *_tmp_68_rule(Parser *p);
static void *_tmp_69_rule(Parser *p);
static void *_tmp_70_rule(Parser *p);
static void *_tmp_71_rule(Parser *p);
static void *_tmp_72_rule(Parser *p);
static void *_tmp_73_rule(Parser *p);
static asdl_seq *_loop0_74_rule(Parser *p);
static void *_tmp_75_rule(Parser *p);
static asdl_seq *_loop1_76_rule(Parser *p);
static void *_tmp_77_rule(Parser *p);
static void *_tmp_78_rule(Parser *p);
static asdl_seq *_loop0_80_rule(Parser *p);
static asdl_seq *_gather_79_rule(Parser *p);
static asdl_seq *_loop0_82_rule(Parser *p);
static asdl_seq *_gather_81_rule(Parser *p);
static asdl_seq *_loop1_83_rule(Parser *p);
static asdl_seq *_loop1_84_rule(Parser *p);
static asdl_seq *_loop1_85_rule(Parser *p);
static asdl_seq *_loop0_87_rule(Parser *p);
static asdl_seq *_gather_86_rule(Parser *p);
static void *_tmp_88_rule(Parser *p);
static void *_tmp_89_rule(Parser *p);
static void *_tmp_90_rule(Parser *p);
static void *_tmp_91_rule(Parser *p);
static asdl_seq *_loop1_92_rule(Parser *p);
static void *_tmp_93_rule(Parser *p);
static void *_tmp_94_rule(Parser *p);
static asdl_seq *_loop0_96_rule(Parser *p);
static asdl_seq *_gather_95_rule(Parser *p);
static asdl_seq *_loop1_97_rule(Parser *p);
static void *_tmp_98_rule(Parser *p);
static void *_tmp_99_rule(Parser *p);
static asdl_seq *_loop0_101_rule(Parser *p);
static asdl_seq *_gather_100_rule(Parser *p);
static asdl_seq *_loop0_103_rule(Parser *p);
static asdl_seq *_gather_102_rule(Parser *p);
static asdl_seq *_loop0_105_rule(Parser *p);
static asdl_seq *_gather_104_rule(Parser *p);
static asdl_seq *_loop0_107_rule(Parser *p);
static asdl_seq *_gather_106_rule(Parser *p);
static asdl_seq *_loop0_108_rule(Parser *p);
static asdl_seq *_loop0_110_rule(Parser *p);
static asdl_seq *_gather_109_rule(Parser *p);
static void *_tmp_111_rule(Parser *p);
static asdl_seq *_loop0_113_rule(Parser *p);
static asdl_seq *_gather_112_rule(Parser *p);
static asdl_seq *_loop0_115_rule(Parser *p);
static asdl_seq *_gather_114_rule(Parser *p);
static void *_tmp_116_rule(Parser *p);
static void *_tmp_117_rule(Parser *p);
static void *_tmp_118_rule(Parser *p);
static void *_tmp_119_rule(Parser *p);
static void *_tmp_120_rule(Parser *p);
static void *_tmp_121_rule(Parser *p);
static void *_tmp_122_rule(Parser *p);
static void *_tmp_123_rule(Parser *p);
static void *_tmp_124_rule(Parser *p);
static void *_tmp_125_rule(Parser *p);
static void *_tmp_126_rule(Parser *p);
static void *_tmp_127_rule(Parser *p);
static void *_tmp_128_rule(Parser *p);
static void *_tmp_129_rule(Parser *p);
static void *_tmp_130_rule(Parser *p);
static void *_tmp_131_rule(Parser *p);
static void *_tmp_132_rule(Parser *p);
static void *_tmp_133_rule(Parser *p);
static void *_tmp_134_rule(Parser *p);
static asdl_seq *_loop0_135_rule(Parser *p);
static void *_tmp_136_rule(Parser *p);


// file: statements? $
static mod_ty
file_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    mod_ty res = NULL;
    int mark = p->mark;
    { // statements? $
        void *a;
        void *endmarker_var;
        if (
            (a = statements_rule(p), 1)
            &&
            (endmarker_var = _PyPegen_endmarker_token(p))
        )
        {
            res = Module ( a , NULL , p -> arena );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// interactive: statement_newline
static mod_ty
interactive_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    mod_ty res = NULL;
    int mark = p->mark;
    { // statement_newline
        asdl_seq* a;
        if (
            (a = statement_newline_rule(p))
        )
        {
            res = Interactive ( a , p -> arena );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// eval: expressions NEWLINE* $
static mod_ty
eval_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    mod_ty res = NULL;
    int mark = p->mark;
    { // expressions NEWLINE* $
        asdl_seq * _loop0_1_var;
        expr_ty a;
        void *endmarker_var;
        if (
            (a = expressions_rule(p))
            &&
            (_loop0_1_var = _loop0_1_rule(p))
            &&
            (endmarker_var = _PyPegen_endmarker_token(p))
        )
        {
            res = Expression ( a , p -> arena );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// fstring: star_expressions
static expr_ty
fstring_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    { // star_expressions
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))
        )
        {
            res = star_expressions_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// statements: statement+
static asdl_seq*
statements_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // statement+
        asdl_seq * a;
        if (
            (a = _loop1_2_rule(p))
        )
        {
            res = _PyPegen_seq_flatten ( p , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// statement: compound_stmt | simple_stmt
static asdl_seq*
statement_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // compound_stmt
        stmt_ty a;
        if (
            (a = compound_stmt_rule(p))
        )
        {
            res = _PyPegen_singleton_seq ( p , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // simple_stmt
        asdl_seq* simple_stmt_var;
        if (
            (simple_stmt_var = simple_stmt_rule(p))
        )
        {
            res = simple_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// statement_newline: compound_stmt NEWLINE | simple_stmt | NEWLINE | $
static asdl_seq*
statement_newline_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // compound_stmt NEWLINE
        stmt_ty a;
        void *newline_var;
        if (
            (a = compound_stmt_rule(p))
            &&
            (newline_var = _PyPegen_newline_token(p))
        )
        {
            res = _PyPegen_singleton_seq ( p , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // simple_stmt
        asdl_seq* simple_stmt_var;
        if (
            (simple_stmt_var = simple_stmt_rule(p))
        )
        {
            res = simple_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // NEWLINE
        void *newline_var;
        if (
            (newline_var = _PyPegen_newline_token(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _PyPegen_singleton_seq ( p , CHECK ( _Py_Pass ( EXTRA ) ) );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // $
        void *endmarker_var;
        if (
            (endmarker_var = _PyPegen_endmarker_token(p))
        )
        {
            res = _PyPegen_interactive_exit ( p );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// simple_stmt: small_stmt !';' NEWLINE | ';'.small_stmt+ ';'? NEWLINE
static asdl_seq*
simple_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // small_stmt !';' NEWLINE
        stmt_ty a;
        void *newline_var;
        if (
            (a = small_stmt_rule(p))
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 13)
            &&
            (newline_var = _PyPegen_newline_token(p))
        )
        {
            res = _PyPegen_singleton_seq ( p , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // ';'.small_stmt+ ';'? NEWLINE
        asdl_seq * a;
        void *newline_var;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = _gather_3_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 13), 1)
            &&
            (newline_var = _PyPegen_newline_token(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// small_stmt:
//     | assignment
//     | star_expressions
//     | &'return' return_stmt
//     | &('import' | 'from') import_stmt
//     | &'raise' raise_stmt
//     | 'pass'
//     | &'del' del_stmt
//     | &'yield' yield_stmt
//     | &'assert' assert_stmt
//     | 'break'
//     | 'continue'
//     | &'global' global_stmt
//     | &'nonlocal' nonlocal_stmt
static stmt_ty
small_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    if (_PyPegen_is_memoized(p, small_stmt_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // assignment
        void *assignment_var;
        if (
            (assignment_var = assignment_rule(p))
        )
        {
            res = assignment_var;
            goto done;
        }
        p->mark = mark;
    }
    { // star_expressions
        expr_ty e;
        if (
            (e = star_expressions_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Expr ( e , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // &'return' return_stmt
        stmt_ty return_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 500)
            &&
            (return_stmt_var = return_stmt_rule(p))
        )
        {
            res = return_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &('import' | 'from') import_stmt
        stmt_ty import_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_5_rule, p)
            &&
            (import_stmt_var = import_stmt_rule(p))
        )
        {
            res = import_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'raise' raise_stmt
        stmt_ty raise_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 501)
            &&
            (raise_stmt_var = raise_stmt_rule(p))
        )
        {
            res = raise_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // 'pass'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 502))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Pass ( EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // &'del' del_stmt
        stmt_ty del_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 503)
            &&
            (del_stmt_var = del_stmt_rule(p))
        )
        {
            res = del_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'yield' yield_stmt
        stmt_ty yield_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 504)
            &&
            (yield_stmt_var = yield_stmt_rule(p))
        )
        {
            res = yield_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'assert' assert_stmt
        stmt_ty assert_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 505)
            &&
            (assert_stmt_var = assert_stmt_rule(p))
        )
        {
            res = assert_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // 'break'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 506))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Break ( EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'continue'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 507))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Continue ( EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // &'global' global_stmt
        stmt_ty global_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 508)
            &&
            (global_stmt_var = global_stmt_rule(p))
        )
        {
            res = global_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'nonlocal' nonlocal_stmt
        stmt_ty nonlocal_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 509)
            &&
            (nonlocal_stmt_var = nonlocal_stmt_rule(p))
        )
        {
            res = nonlocal_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, small_stmt_type, res);
    return res;
}

// compound_stmt:
//     | &('def' | '@' | ASYNC) function_def
//     | &'if' if_stmt
//     | &('class' | '@') class_def
//     | &('with' | ASYNC) with_stmt
//     | &('for' | ASYNC) for_stmt
//     | &'try' try_stmt
//     | &'while' while_stmt
static stmt_ty
compound_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    { // &('def' | '@' | ASYNC) function_def
        stmt_ty function_def_var;
        if (
            _PyPegen_lookahead(1, _tmp_6_rule, p)
            &&
            (function_def_var = function_def_rule(p))
        )
        {
            res = function_def_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'if' if_stmt
        stmt_ty if_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 510)
            &&
            (if_stmt_var = if_stmt_rule(p))
        )
        {
            res = if_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &('class' | '@') class_def
        stmt_ty class_def_var;
        if (
            _PyPegen_lookahead(1, _tmp_7_rule, p)
            &&
            (class_def_var = class_def_rule(p))
        )
        {
            res = class_def_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &('with' | ASYNC) with_stmt
        stmt_ty with_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_8_rule, p)
            &&
            (with_stmt_var = with_stmt_rule(p))
        )
        {
            res = with_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &('for' | ASYNC) for_stmt
        stmt_ty for_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_9_rule, p)
            &&
            (for_stmt_var = for_stmt_rule(p))
        )
        {
            res = for_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'try' try_stmt
        stmt_ty try_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 511)
            &&
            (try_stmt_var = try_stmt_rule(p))
        )
        {
            res = try_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'while' while_stmt
        stmt_ty while_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 512)
            &&
            (while_stmt_var = while_stmt_rule(p))
        )
        {
            res = while_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// assignment:
//     | NAME ':' expression ['=' annotated_rhs]
//     | ('(' inside_paren_ann_assign_target ')' | ann_assign_subscript_attribute_target) ':' expression ['=' annotated_rhs]
//     | ((star_targets '='))+ (yield_expr | star_expressions)
//     | target augassign (yield_expr | star_expressions)
//     | invalid_assignment
static void *
assignment_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME ':' expression ['=' annotated_rhs]
        expr_ty a;
        expr_ty b;
        void *c;
        void *literal;
        if (
            (a = _PyPegen_name_token(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = expression_rule(p))
            &&
            (c = _tmp_10_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_AnnAssign ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , b , c , 1 , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // ('(' inside_paren_ann_assign_target ')' | ann_assign_subscript_attribute_target) ':' expression ['=' annotated_rhs]
        void *a;
        expr_ty b;
        void *c;
        void *literal;
        if (
            (a = _tmp_11_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = expression_rule(p))
            &&
            (c = _tmp_12_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_AnnAssign ( a , b , c , 0 , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // ((star_targets '='))+ (yield_expr | star_expressions)
        asdl_seq * a;
        void *b;
        if (
            (a = _loop1_13_rule(p))
            &&
            (b = _tmp_14_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Assign ( a , b , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // target augassign (yield_expr | star_expressions)
        expr_ty a;
        AugOperator* b;
        void *c;
        if (
            (a = target_rule(p))
            &&
            (b = augassign_rule(p))
            &&
            (c = _tmp_15_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_AugAssign ( a , b -> kind , c , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // invalid_assignment
        void *invalid_assignment_var;
        if (
            (invalid_assignment_var = invalid_assignment_rule(p))
        )
        {
            res = invalid_assignment_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// augassign:
//     | '+='
//     | '-='
//     | '*='
//     | '@='
//     | '/='
//     | '%='
//     | '&='
//     | '|='
//     | '^='
//     | '<<='
//     | '>>='
//     | '**='
//     | '//='
static AugOperator*
augassign_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    AugOperator* res = NULL;
    int mark = p->mark;
    { // '+='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 36))
        )
        {
            res = _PyPegen_augoperator ( p , Add );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '-='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 37))
        )
        {
            res = _PyPegen_augoperator ( p , Sub );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '*='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 38))
        )
        {
            res = _PyPegen_augoperator ( p , Mult );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '@='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 50))
        )
        {
            res = _PyPegen_augoperator ( p , MatMult );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '/='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 39))
        )
        {
            res = _PyPegen_augoperator ( p , Div );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '%='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 40))
        )
        {
            res = _PyPegen_augoperator ( p , Mod );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '&='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 41))
        )
        {
            res = _PyPegen_augoperator ( p , BitAnd );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '|='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 42))
        )
        {
            res = _PyPegen_augoperator ( p , BitOr );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '^='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 43))
        )
        {
            res = _PyPegen_augoperator ( p , BitXor );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '<<='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 44))
        )
        {
            res = _PyPegen_augoperator ( p , LShift );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '>>='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 45))
        )
        {
            res = _PyPegen_augoperator ( p , RShift );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '**='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 46))
        )
        {
            res = _PyPegen_augoperator ( p , Pow );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '//='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 48))
        )
        {
            res = _PyPegen_augoperator ( p , FloorDiv );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// global_stmt: 'global' ','.NAME+
static stmt_ty
global_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'global' ','.NAME+
        asdl_seq * a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 508))
            &&
            (a = _gather_16_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Global ( CHECK ( _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// nonlocal_stmt: 'nonlocal' ','.NAME+
static stmt_ty
nonlocal_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'nonlocal' ','.NAME+
        asdl_seq * a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 509))
            &&
            (a = _gather_18_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Nonlocal ( CHECK ( _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// yield_stmt: yield_expr
static stmt_ty
yield_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // yield_expr
        expr_ty y;
        if (
            (y = yield_expr_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Expr ( y , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// assert_stmt: 'assert' expression [',' expression]
static stmt_ty
assert_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'assert' expression [',' expression]
        expr_ty a;
        void *b;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 505))
            &&
            (a = expression_rule(p))
            &&
            (b = _tmp_20_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Assert ( a , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// del_stmt: 'del' del_targets
static stmt_ty
del_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'del' del_targets
        asdl_seq* a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 503))
            &&
            (a = del_targets_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Delete ( a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// import_stmt: import_name | import_from
static stmt_ty
import_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    { // import_name
        stmt_ty import_name_var;
        if (
            (import_name_var = import_name_rule(p))
        )
        {
            res = import_name_var;
            goto done;
        }
        p->mark = mark;
    }
    { // import_from
        stmt_ty import_from_var;
        if (
            (import_from_var = import_from_rule(p))
        )
        {
            res = import_from_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// import_name: 'import' dotted_as_names
static stmt_ty
import_name_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'import' dotted_as_names
        asdl_seq* a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 513))
            &&
            (a = dotted_as_names_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Import ( a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// import_from:
//     | 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
//     | 'from' (('.' | '...'))+ 'import' import_from_targets
static stmt_ty
import_from_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
        asdl_seq * a;
        expr_ty b;
        asdl_seq* c;
        void *keyword;
        void *keyword_1;
        if (
            (keyword = _PyPegen_expect_token(p, 514))
            &&
            (a = _loop0_21_rule(p))
            &&
            (b = dotted_name_rule(p))
            &&
            (keyword_1 = _PyPegen_expect_token(p, 513))
            &&
            (c = import_from_targets_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_ImportFrom ( b -> v . Name . id , c , _PyPegen_seq_count_dots ( a ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'from' (('.' | '...'))+ 'import' import_from_targets
        asdl_seq * a;
        asdl_seq* b;
        void *keyword;
        void *keyword_1;
        if (
            (keyword = _PyPegen_expect_token(p, 514))
            &&
            (a = _loop1_22_rule(p))
            &&
            (keyword_1 = _PyPegen_expect_token(p, 513))
            &&
            (b = import_from_targets_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_ImportFrom ( NULL , b , _PyPegen_seq_count_dots ( a ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names | '*'
static asdl_seq*
import_from_targets_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // '(' import_from_as_names ','? ')'
        asdl_seq* a;
        void *literal;
        void *literal_1;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = import_from_as_names_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // import_from_as_names
        asdl_seq* import_from_as_names_var;
        if (
            (import_from_as_names_var = import_from_as_names_rule(p))
        )
        {
            res = import_from_as_names_var;
            goto done;
        }
        p->mark = mark;
    }
    { // '*'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 16))
        )
        {
            res = _PyPegen_singleton_seq ( p , CHECK ( _PyPegen_alias_for_star ( p ) ) );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// import_from_as_names: ','.import_from_as_name+
static asdl_seq*
import_from_as_names_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.import_from_as_name+
        asdl_seq * a;
        if (
            (a = _gather_23_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// import_from_as_name: NAME ['as' NAME]
static alias_ty
import_from_as_name_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    alias_ty res = NULL;
    int mark = p->mark;
    { // NAME ['as' NAME]
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))
            &&
            (b = _tmp_25_rule(p), 1)
        )
        {
            res = _Py_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , p -> arena );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// dotted_as_names: ','.dotted_as_name+
static asdl_seq*
dotted_as_names_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.dotted_as_name+
        asdl_seq * a;
        if (
            (a = _gather_26_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// dotted_as_name: dotted_name ['as' NAME]
static alias_ty
dotted_as_name_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    alias_ty res = NULL;
    int mark = p->mark;
    { // dotted_name ['as' NAME]
        expr_ty a;
        void *b;
        if (
            (a = dotted_name_rule(p))
            &&
            (b = _tmp_28_rule(p), 1)
        )
        {
            res = _Py_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , p -> arena );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// Left-recursive
// dotted_name: dotted_name '.' NAME | NAME
static expr_ty dotted_name_raw(Parser *);
static expr_ty
dotted_name_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, dotted_name_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_0 = _PyPegen_update_memo(p, mark, dotted_name_type, res);
        if (tmpvar_0) {
            return res;
        }
        p->mark = mark;
        void *raw = dotted_name_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
dotted_name_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    { // dotted_name '.' NAME
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = dotted_name_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 23))
            &&
            (b = _PyPegen_name_token(p))
        )
        {
            res = _PyPegen_join_names_with_dot ( p , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // NAME
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))
        )
        {
            res = name_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// if_stmt:
//     | 'if' named_expression ':' block elif_stmt
//     | 'if' named_expression ':' block else_block?
static stmt_ty
if_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'if' named_expression ':' block elif_stmt
        expr_ty a;
        asdl_seq* b;
        stmt_ty c;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 510))
            &&
            (a = named_expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
            &&
            (c = elif_stmt_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_If ( a , b , CHECK ( _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'if' named_expression ':' block else_block?
        expr_ty a;
        asdl_seq* b;
        void *c;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 510))
            &&
            (a = named_expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
            &&
            (c = else_block_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_If ( a , b , c , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// elif_stmt:
//     | 'elif' named_expression ':' block elif_stmt
//     | 'elif' named_expression ':' block else_block?
static stmt_ty
elif_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'elif' named_expression ':' block elif_stmt
        expr_ty a;
        asdl_seq* b;
        stmt_ty c;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 515))
            &&
            (a = named_expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
            &&
            (c = elif_stmt_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_If ( a , b , CHECK ( _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'elif' named_expression ':' block else_block?
        expr_ty a;
        asdl_seq* b;
        void *c;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 515))
            &&
            (a = named_expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
            &&
            (c = else_block_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_If ( a , b , c , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// else_block: 'else' ':' block
static asdl_seq*
else_block_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // 'else' ':' block
        asdl_seq* b;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 516))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
        )
        {
            res = b;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// while_stmt: 'while' named_expression ':' block else_block?
static stmt_ty
while_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'while' named_expression ':' block else_block?
        expr_ty a;
        asdl_seq* b;
        void *c;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 512))
            &&
            (a = named_expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
            &&
            (c = else_block_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_While ( a , b , c , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// for_stmt: ASYNC? 'for' star_targets 'in' star_expressions ':' block else_block?
static stmt_ty
for_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // ASYNC? 'for' star_targets 'in' star_expressions ':' block else_block?
        asdl_seq* b;
        void *el;
        expr_ty ex;
        void *is_async;
        void *keyword;
        void *keyword_1;
        void *literal;
        expr_ty t;
        if (
            (is_async = _PyPegen_async_token(p), 1)
            &&
            (keyword = _PyPegen_expect_token(p, 517))
            &&
            (t = star_targets_rule(p))
            &&
            (keyword_1 = _PyPegen_expect_token(p, 518))
            &&
            (ex = star_expressions_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
            &&
            (el = else_block_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = ( is_async ? _Py_AsyncFor : _Py_For ) ( t , ex , b , el , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// with_stmt:
//     | ASYNC? 'with' '(' ','.with_item+ ')' ':' block
//     | ASYNC? 'with' ','.with_item+ ':' block
static stmt_ty
with_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // ASYNC? 'with' '(' ','.with_item+ ')' ':' block
        asdl_seq * a;
        asdl_seq* b;
        void *is_async;
        void *keyword;
        void *literal;
        void *literal_1;
        void *literal_2;
        if (
            (is_async = _PyPegen_async_token(p), 1)
            &&
            (keyword = _PyPegen_expect_token(p, 519))
            &&
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = _gather_29_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
            &&
            (literal_2 = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = ( is_async ? _Py_AsyncWith : _Py_With ) ( a , b , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // ASYNC? 'with' ','.with_item+ ':' block
        asdl_seq * a;
        asdl_seq* b;
        void *is_async;
        void *keyword;
        void *literal;
        if (
            (is_async = _PyPegen_async_token(p), 1)
            &&
            (keyword = _PyPegen_expect_token(p, 519))
            &&
            (a = _gather_31_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = ( is_async ? _Py_AsyncWith : _Py_With ) ( a , b , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// with_item: expression ['as' target]
static withitem_ty
with_item_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    withitem_ty res = NULL;
    int mark = p->mark;
    { // expression ['as' target]
        expr_ty e;
        void *o;
        if (
            (e = expression_rule(p))
            &&
            (o = _tmp_33_rule(p), 1)
        )
        {
            res = _Py_withitem ( e , o , p -> arena );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// try_stmt:
//     | 'try' ':' block finally_block
//     | 'try' ':' block except_block+ else_block? finally_block?
static stmt_ty
try_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'try' ':' block finally_block
        asdl_seq* b;
        asdl_seq* f;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 511))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
            &&
            (f = finally_block_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Try ( b , NULL , NULL , f , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'try' ':' block except_block+ else_block? finally_block?
        asdl_seq* b;
        void *el;
        asdl_seq * ex;
        void *f;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 511))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
            &&
            (ex = _loop1_34_rule(p))
            &&
            (el = else_block_rule(p), 1)
            &&
            (f = finally_block_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Try ( b , ex , el , f , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// except_block: 'except' expression ['as' target] ':' block | 'except' ':' block
static excepthandler_ty
except_block_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    excepthandler_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'except' expression ['as' target] ':' block
        asdl_seq* b;
        expr_ty e;
        void *keyword;
        void *literal;
        void *t;
        if (
            (keyword = _PyPegen_expect_token(p, 520))
            &&
            (e = expression_rule(p))
            &&
            (t = _tmp_35_rule(p), 1)
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_ExceptHandler ( e , ( t ) ? ( ( expr_ty ) t ) -> v . Name . id : NULL , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'except' ':' block
        asdl_seq* b;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 520))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_ExceptHandler ( NULL , NULL , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// finally_block: 'finally' ':' block
static asdl_seq*
finally_block_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // 'finally' ':' block
        asdl_seq* a;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 521))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (a = block_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// return_stmt: 'return' star_expressions?
static stmt_ty
return_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'return' star_expressions?
        void *a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 500))
            &&
            (a = star_expressions_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Return ( a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// raise_stmt: 'raise' expression ['from' expression] | 'raise'
static stmt_ty
raise_stmt_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'raise' expression ['from' expression]
        expr_ty a;
        void *b;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 501))
            &&
            (a = expression_rule(p))
            &&
            (b = _tmp_36_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Raise ( a , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'raise'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 501))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Raise ( NULL , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// function_def: decorators function_def_raw | function_def_raw
static stmt_ty
function_def_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    { // decorators function_def_raw
        asdl_seq* d;
        stmt_ty f;
        if (
            (d = decorators_rule(p))
            &&
            (f = function_def_raw_rule(p))
        )
        {
            res = _PyPegen_function_def_decorators ( p , d , f );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // function_def_raw
        stmt_ty function_def_raw_var;
        if (
            (function_def_raw_var = function_def_raw_rule(p))
        )
        {
            res = function_def_raw_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// function_def_raw: ASYNC? 'def' NAME '(' params? ')' ['->' annotation] ':' block
static stmt_ty
function_def_raw_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // ASYNC? 'def' NAME '(' params? ')' ['->' annotation] ':' block
        void *a;
        asdl_seq* b;
        void *is_async;
        void *keyword;
        void *literal;
        void *literal_1;
        void *literal_2;
        expr_ty n;
        void *params;
        if (
            (is_async = _PyPegen_async_token(p), 1)
            &&
            (keyword = _PyPegen_expect_token(p, 522))
            &&
            (n = _PyPegen_name_token(p))
            &&
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (params = params_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
            &&
            (a = _tmp_37_rule(p), 1)
            &&
            (literal_2 = _PyPegen_expect_token(p, 11))
            &&
            (b = block_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = ( is_async ? _Py_AsyncFunctionDef : _Py_FunctionDef ) ( n -> v . Name . id , ( params ) ? params : CHECK ( _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// params: invalid_parameters | parameters
static arguments_ty
params_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    arguments_ty res = NULL;
    int mark = p->mark;
    { // invalid_parameters
        void *invalid_parameters_var;
        if (
            (invalid_parameters_var = invalid_parameters_rule(p))
        )
        {
            res = invalid_parameters_var;
            goto done;
        }
        p->mark = mark;
    }
    { // parameters
        arguments_ty parameters_var;
        if (
            (parameters_var = parameters_rule(p))
        )
        {
            res = parameters_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// parameters:
//     | slash_without_default [',' plain_names] [',' names_with_default] [',' star_etc?]
//     | slash_with_default [',' names_with_default] [',' star_etc?]
//     | plain_names [',' names_with_default] [',' star_etc?]
//     | names_with_default [',' star_etc?]
//     | star_etc
static arguments_ty
parameters_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    arguments_ty res = NULL;
    int mark = p->mark;
    { // slash_without_default [',' plain_names] [',' names_with_default] [',' star_etc?]
        asdl_seq* a;
        void *b;
        void *c;
        void *d;
        if (
            (a = slash_without_default_rule(p))
            &&
            (b = _tmp_38_rule(p), 1)
            &&
            (c = _tmp_39_rule(p), 1)
            &&
            (d = _tmp_40_rule(p), 1)
        )
        {
            res = _PyPegen_make_arguments ( p , a , NULL , b , c , d );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // slash_with_default [',' names_with_default] [',' star_etc?]
        SlashWithDefault* a;
        void *b;
        void *c;
        if (
            (a = slash_with_default_rule(p))
            &&
            (b = _tmp_41_rule(p), 1)
            &&
            (c = _tmp_42_rule(p), 1)
        )
        {
            res = _PyPegen_make_arguments ( p , NULL , a , NULL , b , c );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // plain_names [',' names_with_default] [',' star_etc?]
        asdl_seq* a;
        void *b;
        void *c;
        if (
            (a = plain_names_rule(p))
            &&
            (b = _tmp_43_rule(p), 1)
            &&
            (c = _tmp_44_rule(p), 1)
        )
        {
            res = _PyPegen_make_arguments ( p , NULL , NULL , a , b , c );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // names_with_default [',' star_etc?]
        asdl_seq* a;
        void *b;
        if (
            (a = names_with_default_rule(p))
            &&
            (b = _tmp_45_rule(p), 1)
        )
        {
            res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // star_etc
        StarEtc* a;
        if (
            (a = star_etc_rule(p))
        )
        {
            res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// slash_without_default: plain_names ',' '/'
static asdl_seq*
slash_without_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // plain_names ',' '/'
        asdl_seq* a;
        void *literal;
        void *literal_1;
        if (
            (a = plain_names_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (literal_1 = _PyPegen_expect_token(p, 17))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// slash_with_default: [plain_names ','] names_with_default ',' '/'
static SlashWithDefault*
slash_with_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    SlashWithDefault* res = NULL;
    int mark = p->mark;
    { // [plain_names ','] names_with_default ',' '/'
        void *a;
        asdl_seq* b;
        void *literal;
        void *literal_1;
        if (
            (a = _tmp_46_rule(p), 1)
            &&
            (b = names_with_default_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (literal_1 = _PyPegen_expect_token(p, 17))
        )
        {
            res = _PyPegen_slash_with_default ( p , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// star_etc:
//     | '*' plain_name name_with_optional_default* [',' kwds] ','?
//     | '*' name_with_optional_default+ [',' kwds] ','?
//     | kwds ','?
static StarEtc*
star_etc_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    StarEtc* res = NULL;
    int mark = p->mark;
    { // '*' plain_name name_with_optional_default* [',' kwds] ','?
        arg_ty a;
        asdl_seq * b;
        void *c;
        void *literal;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (a = plain_name_rule(p))
            &&
            (b = _loop0_47_rule(p))
            &&
            (c = _tmp_48_rule(p), 1)
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = _PyPegen_star_etc ( p , a , b , c );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '*' name_with_optional_default+ [',' kwds] ','?
        asdl_seq * b;
        void *c;
        void *literal;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (b = _loop1_49_rule(p))
            &&
            (c = _tmp_50_rule(p), 1)
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = _PyPegen_star_etc ( p , NULL , b , c );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // kwds ','?
        arg_ty a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = kwds_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = _PyPegen_star_etc ( p , NULL , NULL , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// name_with_optional_default: ',' plain_name ['=' expression]
static NameDefaultPair*
name_with_optional_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    NameDefaultPair* res = NULL;
    int mark = p->mark;
    { // ',' plain_name ['=' expression]
        arg_ty a;
        void *b;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (a = plain_name_rule(p))
            &&
            (b = _tmp_51_rule(p), 1)
        )
        {
            res = _PyPegen_name_default_pair ( p , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// names_with_default: ','.name_with_default+
static asdl_seq*
names_with_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.name_with_default+
        asdl_seq * a;
        if (
            (a = _gather_52_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// name_with_default: plain_name '=' expression
static NameDefaultPair*
name_with_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    NameDefaultPair* res = NULL;
    int mark = p->mark;
    { // plain_name '=' expression
        expr_ty e;
        void *literal;
        arg_ty n;
        if (
            (n = plain_name_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (e = expression_rule(p))
        )
        {
            res = _PyPegen_name_default_pair ( p , n , e );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// plain_names: ','.(plain_name !'=')+
static asdl_seq*
plain_names_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    if (_PyPegen_is_memoized(p, plain_names_type, &res))
        return res;
    int mark = p->mark;
    { // ','.(plain_name !'=')+
        asdl_seq * a;
        if (
            (a = _gather_54_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, plain_names_type, res);
    return res;
}

// plain_name: NAME [':' annotation]
static arg_ty
plain_name_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    arg_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME [':' annotation]
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))
            &&
            (b = _tmp_56_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_arg ( a -> v . Name . id , b , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// kwds: '**' plain_name
static arg_ty
kwds_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    arg_ty res = NULL;
    int mark = p->mark;
    { // '**' plain_name
        arg_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 35))
            &&
            (a = plain_name_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// annotation: expression
static expr_ty
annotation_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    { // expression
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))
        )
        {
            res = expression_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// decorators: (('@' named_expression NEWLINE))+
static asdl_seq*
decorators_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // (('@' named_expression NEWLINE))+
        asdl_seq * a;
        if (
            (a = _loop1_57_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// class_def: decorators class_def_raw | class_def_raw
static stmt_ty
class_def_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    { // decorators class_def_raw
        asdl_seq* a;
        stmt_ty b;
        if (
            (a = decorators_rule(p))
            &&
            (b = class_def_raw_rule(p))
        )
        {
            res = _PyPegen_class_def_decorators ( p , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // class_def_raw
        stmt_ty class_def_raw_var;
        if (
            (class_def_raw_var = class_def_raw_rule(p))
        )
        {
            res = class_def_raw_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// class_def_raw: 'class' NAME ['(' arguments? ')'] ':' block
static stmt_ty
class_def_raw_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    stmt_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'class' NAME ['(' arguments? ')'] ':' block
        expr_ty a;
        void *b;
        asdl_seq* c;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 523))
            &&
            (a = _PyPegen_name_token(p))
            &&
            (b = _tmp_58_rule(p), 1)
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (c = block_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_ClassDef ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , c , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// block: NEWLINE INDENT statements DEDENT | simple_stmt | invalid_block
static asdl_seq*
block_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    if (_PyPegen_is_memoized(p, block_type, &res))
        return res;
    int mark = p->mark;
    { // NEWLINE INDENT statements DEDENT
        asdl_seq* a;
        void *dedent_var;
        void *indent_var;
        void *newline_var;
        if (
            (newline_var = _PyPegen_newline_token(p))
            &&
            (indent_var = _PyPegen_indent_token(p))
            &&
            (a = statements_rule(p))
            &&
            (dedent_var = _PyPegen_dedent_token(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // simple_stmt
        asdl_seq* simple_stmt_var;
        if (
            (simple_stmt_var = simple_stmt_rule(p))
        )
        {
            res = simple_stmt_var;
            goto done;
        }
        p->mark = mark;
    }
    { // invalid_block
        void *invalid_block_var;
        if (
            (invalid_block_var = invalid_block_rule(p))
        )
        {
            res = invalid_block_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, block_type, res);
    return res;
}

// expressions_list: ','.star_expression+ ','?
static asdl_seq*
expressions_list_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.star_expression+ ','?
        asdl_seq * a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = _gather_59_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// star_expressions:
//     | star_expression ((',' star_expression))+ ','?
//     | star_expression ','
//     | star_expression
static expr_ty
star_expressions_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // star_expression ((',' star_expression))+ ','?
        expr_ty a;
        asdl_seq * b;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = star_expression_rule(p))
            &&
            (b = _loop1_61_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // star_expression ','
        expr_ty a;
        void *literal;
        if (
            (a = star_expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( CHECK ( _PyPegen_singleton_seq ( p , a ) ) , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // star_expression
        expr_ty star_expression_var;
        if (
            (star_expression_var = star_expression_rule(p))
        )
        {
            res = star_expression_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// star_expression: '*' bitwise_or | expression
static expr_ty
star_expression_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, star_expression_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '*' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Starred ( a , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))
        )
        {
            res = expression_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, star_expression_type, res);
    return res;
}

// star_named_expressions: ','.star_named_expression+ ','?
static asdl_seq*
star_named_expressions_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.star_named_expression+ ','?
        asdl_seq * a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = _gather_62_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// star_named_expression: '*' bitwise_or | named_expression
static expr_ty
star_named_expression_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '*' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Starred ( a , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // named_expression
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))
        )
        {
            res = named_expression_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// named_expression: NAME ':=' expression | expression !':=' | invalid_named_expression
static expr_ty
named_expression_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME ':=' expression
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = _PyPegen_name_token(p))
            &&
            (literal = _PyPegen_expect_token(p, 53))
            &&
            (b = expression_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_NamedExpr ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression !':='
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)
        )
        {
            res = expression_var;
            goto done;
        }
        p->mark = mark;
    }
    { // invalid_named_expression
        void *invalid_named_expression_var;
        if (
            (invalid_named_expression_var = invalid_named_expression_rule(p))
        )
        {
            res = invalid_named_expression_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// annotated_rhs: yield_expr | star_expressions
static expr_ty
annotated_rhs_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    { // yield_expr
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))
        )
        {
            res = yield_expr_var;
            goto done;
        }
        p->mark = mark;
    }
    { // star_expressions
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))
        )
        {
            res = star_expressions_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// expressions: expression ((',' expression))+ ','? | expression ',' | expression
static expr_ty
expressions_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // expression ((',' expression))+ ','?
        expr_ty a;
        asdl_seq * b;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = expression_rule(p))
            &&
            (b = _loop1_64_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression ','
        expr_ty a;
        void *literal;
        if (
            (a = expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( CHECK ( _PyPegen_singleton_seq ( p , a ) ) , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))
        )
        {
            res = expression_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// expression: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
static expr_ty
expression_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, expression_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // disjunction 'if' disjunction 'else' expression
        expr_ty a;
        expr_ty b;
        expr_ty c;
        void *keyword;
        void *keyword_1;
        if (
            (a = disjunction_rule(p))
            &&
            (keyword = _PyPegen_expect_token(p, 510))
            &&
            (b = disjunction_rule(p))
            &&
            (keyword_1 = _PyPegen_expect_token(p, 516))
            &&
            (c = expression_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_IfExp ( b , a , c , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // disjunction
        expr_ty disjunction_var;
        if (
            (disjunction_var = disjunction_rule(p))
        )
        {
            res = disjunction_var;
            goto done;
        }
        p->mark = mark;
    }
    { // lambdef
        expr_ty lambdef_var;
        if (
            (lambdef_var = lambdef_rule(p))
        )
        {
            res = lambdef_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, expression_type, res);
    return res;
}

// lambdef: 'lambda' lambda_parameters? ':' expression
static expr_ty
lambdef_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'lambda' lambda_parameters? ':' expression
        void *a;
        expr_ty b;
        void *keyword;
        void *literal;
        if (
            (keyword = _PyPegen_expect_token(p, 524))
            &&
            (a = lambda_parameters_rule(p), 1)
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = expression_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Lambda ( ( a ) ? a : CHECK ( _PyPegen_empty_arguments ( p ) ) , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_parameters:
//     | lambda_slash_without_default [',' lambda_plain_names] [',' lambda_names_with_default] [',' lambda_star_etc?]
//     | lambda_slash_with_default [',' lambda_names_with_default] [',' lambda_star_etc?]
//     | lambda_plain_names [',' lambda_names_with_default] [',' lambda_star_etc?]
//     | lambda_names_with_default [',' lambda_star_etc?]
//     | lambda_star_etc
static arguments_ty
lambda_parameters_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    arguments_ty res = NULL;
    int mark = p->mark;
    { // lambda_slash_without_default [',' lambda_plain_names] [',' lambda_names_with_default] [',' lambda_star_etc?]
        asdl_seq* a;
        void *b;
        void *c;
        void *d;
        if (
            (a = lambda_slash_without_default_rule(p))
            &&
            (b = _tmp_65_rule(p), 1)
            &&
            (c = _tmp_66_rule(p), 1)
            &&
            (d = _tmp_67_rule(p), 1)
        )
        {
            res = _PyPegen_make_arguments ( p , a , NULL , b , c , d );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // lambda_slash_with_default [',' lambda_names_with_default] [',' lambda_star_etc?]
        SlashWithDefault* a;
        void *b;
        void *c;
        if (
            (a = lambda_slash_with_default_rule(p))
            &&
            (b = _tmp_68_rule(p), 1)
            &&
            (c = _tmp_69_rule(p), 1)
        )
        {
            res = _PyPegen_make_arguments ( p , NULL , a , NULL , b , c );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // lambda_plain_names [',' lambda_names_with_default] [',' lambda_star_etc?]
        asdl_seq* a;
        void *b;
        void *c;
        if (
            (a = lambda_plain_names_rule(p))
            &&
            (b = _tmp_70_rule(p), 1)
            &&
            (c = _tmp_71_rule(p), 1)
        )
        {
            res = _PyPegen_make_arguments ( p , NULL , NULL , a , b , c );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // lambda_names_with_default [',' lambda_star_etc?]
        asdl_seq* a;
        void *b;
        if (
            (a = lambda_names_with_default_rule(p))
            &&
            (b = _tmp_72_rule(p), 1)
        )
        {
            res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // lambda_star_etc
        StarEtc* a;
        if (
            (a = lambda_star_etc_rule(p))
        )
        {
            res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_slash_without_default: lambda_plain_names ',' '/'
static asdl_seq*
lambda_slash_without_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // lambda_plain_names ',' '/'
        asdl_seq* a;
        void *literal;
        void *literal_1;
        if (
            (a = lambda_plain_names_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (literal_1 = _PyPegen_expect_token(p, 17))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_slash_with_default: [lambda_plain_names ','] lambda_names_with_default ',' '/'
static SlashWithDefault*
lambda_slash_with_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    SlashWithDefault* res = NULL;
    int mark = p->mark;
    { // [lambda_plain_names ','] lambda_names_with_default ',' '/'
        void *a;
        asdl_seq* b;
        void *literal;
        void *literal_1;
        if (
            (a = _tmp_73_rule(p), 1)
            &&
            (b = lambda_names_with_default_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (literal_1 = _PyPegen_expect_token(p, 17))
        )
        {
            res = _PyPegen_slash_with_default ( p , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_star_etc:
//     | '*' lambda_plain_name lambda_name_with_optional_default* [',' lambda_kwds] ','?
//     | '*' lambda_name_with_optional_default+ [',' lambda_kwds] ','?
//     | lambda_kwds ','?
static StarEtc*
lambda_star_etc_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    StarEtc* res = NULL;
    int mark = p->mark;
    { // '*' lambda_plain_name lambda_name_with_optional_default* [',' lambda_kwds] ','?
        arg_ty a;
        asdl_seq * b;
        void *c;
        void *literal;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (a = lambda_plain_name_rule(p))
            &&
            (b = _loop0_74_rule(p))
            &&
            (c = _tmp_75_rule(p), 1)
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = _PyPegen_star_etc ( p , a , b , c );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '*' lambda_name_with_optional_default+ [',' lambda_kwds] ','?
        asdl_seq * b;
        void *c;
        void *literal;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (b = _loop1_76_rule(p))
            &&
            (c = _tmp_77_rule(p), 1)
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = _PyPegen_star_etc ( p , NULL , b , c );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // lambda_kwds ','?
        arg_ty a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = lambda_kwds_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = _PyPegen_star_etc ( p , NULL , NULL , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_name_with_optional_default: ',' lambda_plain_name ['=' expression]
static NameDefaultPair*
lambda_name_with_optional_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    NameDefaultPair* res = NULL;
    int mark = p->mark;
    { // ',' lambda_plain_name ['=' expression]
        arg_ty a;
        void *b;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (a = lambda_plain_name_rule(p))
            &&
            (b = _tmp_78_rule(p), 1)
        )
        {
            res = _PyPegen_name_default_pair ( p , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_names_with_default: ','.lambda_name_with_default+
static asdl_seq*
lambda_names_with_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.lambda_name_with_default+
        asdl_seq * a;
        if (
            (a = _gather_79_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_name_with_default: lambda_plain_name '=' expression
static NameDefaultPair*
lambda_name_with_default_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    NameDefaultPair* res = NULL;
    int mark = p->mark;
    { // lambda_plain_name '=' expression
        expr_ty e;
        void *literal;
        arg_ty n;
        if (
            (n = lambda_plain_name_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (e = expression_rule(p))
        )
        {
            res = _PyPegen_name_default_pair ( p , n , e );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_plain_names: ','.(lambda_plain_name !'=')+
static asdl_seq*
lambda_plain_names_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.(lambda_plain_name !'=')+
        asdl_seq * a;
        if (
            (a = _gather_81_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_plain_name: NAME
static arg_ty
lambda_plain_name_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    arg_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_arg ( a -> v . Name . id , NULL , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lambda_kwds: '**' lambda_plain_name
static arg_ty
lambda_kwds_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    arg_ty res = NULL;
    int mark = p->mark;
    { // '**' lambda_plain_name
        arg_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 35))
            &&
            (a = lambda_plain_name_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// disjunction: conjunction (('or' conjunction))+ | conjunction
static expr_ty
disjunction_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, disjunction_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // conjunction (('or' conjunction))+
        expr_ty a;
        asdl_seq * b;
        if (
            (a = conjunction_rule(p))
            &&
            (b = _loop1_83_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BoolOp ( Or , CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // conjunction
        expr_ty conjunction_var;
        if (
            (conjunction_var = conjunction_rule(p))
        )
        {
            res = conjunction_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, disjunction_type, res);
    return res;
}

// conjunction: inversion (('and' inversion))+ | inversion
static expr_ty
conjunction_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, conjunction_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // inversion (('and' inversion))+
        expr_ty a;
        asdl_seq * b;
        if (
            (a = inversion_rule(p))
            &&
            (b = _loop1_84_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BoolOp ( And , CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // inversion
        expr_ty inversion_var;
        if (
            (inversion_var = inversion_rule(p))
        )
        {
            res = inversion_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, conjunction_type, res);
    return res;
}

// inversion: 'not' inversion | comparison
static expr_ty
inversion_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, inversion_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'not' inversion
        expr_ty a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 525))
            &&
            (a = inversion_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_UnaryOp ( Not , a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // comparison
        expr_ty comparison_var;
        if (
            (comparison_var = comparison_rule(p))
        )
        {
            res = comparison_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, inversion_type, res);
    return res;
}

// comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
static expr_ty
comparison_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // bitwise_or compare_op_bitwise_or_pair+
        expr_ty a;
        asdl_seq * b;
        if (
            (a = bitwise_or_rule(p))
            &&
            (b = _loop1_85_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Compare ( a , CHECK ( _PyPegen_get_cmpops ( p , b ) ) , CHECK ( _PyPegen_get_exprs ( p , b ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // bitwise_or
        expr_ty bitwise_or_var;
        if (
            (bitwise_or_var = bitwise_or_rule(p))
        )
        {
            res = bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// compare_op_bitwise_or_pair:
//     | eq_bitwise_or
//     | noteq_bitwise_or
//     | lte_bitwise_or
//     | lt_bitwise_or
//     | gte_bitwise_or
//     | gt_bitwise_or
//     | notin_bitwise_or
//     | in_bitwise_or
//     | isnot_bitwise_or
//     | is_bitwise_or
static CmpopExprPair*
compare_op_bitwise_or_pair_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // eq_bitwise_or
        CmpopExprPair* eq_bitwise_or_var;
        if (
            (eq_bitwise_or_var = eq_bitwise_or_rule(p))
        )
        {
            res = eq_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // noteq_bitwise_or
        CmpopExprPair* noteq_bitwise_or_var;
        if (
            (noteq_bitwise_or_var = noteq_bitwise_or_rule(p))
        )
        {
            res = noteq_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // lte_bitwise_or
        CmpopExprPair* lte_bitwise_or_var;
        if (
            (lte_bitwise_or_var = lte_bitwise_or_rule(p))
        )
        {
            res = lte_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // lt_bitwise_or
        CmpopExprPair* lt_bitwise_or_var;
        if (
            (lt_bitwise_or_var = lt_bitwise_or_rule(p))
        )
        {
            res = lt_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // gte_bitwise_or
        CmpopExprPair* gte_bitwise_or_var;
        if (
            (gte_bitwise_or_var = gte_bitwise_or_rule(p))
        )
        {
            res = gte_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // gt_bitwise_or
        CmpopExprPair* gt_bitwise_or_var;
        if (
            (gt_bitwise_or_var = gt_bitwise_or_rule(p))
        )
        {
            res = gt_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // notin_bitwise_or
        CmpopExprPair* notin_bitwise_or_var;
        if (
            (notin_bitwise_or_var = notin_bitwise_or_rule(p))
        )
        {
            res = notin_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // in_bitwise_or
        CmpopExprPair* in_bitwise_or_var;
        if (
            (in_bitwise_or_var = in_bitwise_or_rule(p))
        )
        {
            res = in_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // isnot_bitwise_or
        CmpopExprPair* isnot_bitwise_or_var;
        if (
            (isnot_bitwise_or_var = isnot_bitwise_or_rule(p))
        )
        {
            res = isnot_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    { // is_bitwise_or
        CmpopExprPair* is_bitwise_or_var;
        if (
            (is_bitwise_or_var = is_bitwise_or_rule(p))
        )
        {
            res = is_bitwise_or_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// eq_bitwise_or: '==' bitwise_or
static CmpopExprPair*
eq_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // '==' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 27))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , Eq , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// noteq_bitwise_or: '!=' bitwise_or
static CmpopExprPair*
noteq_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // '!=' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 28))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , NotEq , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lte_bitwise_or: '<=' bitwise_or
static CmpopExprPair*
lte_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // '<=' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 29))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , LtE , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// lt_bitwise_or: '<' bitwise_or
static CmpopExprPair*
lt_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // '<' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 20))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , Lt , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// gte_bitwise_or: '>=' bitwise_or
static CmpopExprPair*
gte_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // '>=' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 30))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , GtE , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// gt_bitwise_or: '>' bitwise_or
static CmpopExprPair*
gt_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // '>' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 21))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , Gt , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// notin_bitwise_or: 'not' 'in' bitwise_or
static CmpopExprPair*
notin_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // 'not' 'in' bitwise_or
        expr_ty a;
        void *keyword;
        void *keyword_1;
        if (
            (keyword = _PyPegen_expect_token(p, 525))
            &&
            (keyword_1 = _PyPegen_expect_token(p, 518))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , NotIn , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// in_bitwise_or: 'in' bitwise_or
static CmpopExprPair*
in_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // 'in' bitwise_or
        expr_ty a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 518))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , In , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// isnot_bitwise_or: 'is' 'not' bitwise_or
static CmpopExprPair*
isnot_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // 'is' 'not' bitwise_or
        expr_ty a;
        void *keyword;
        void *keyword_1;
        if (
            (keyword = _PyPegen_expect_token(p, 526))
            &&
            (keyword_1 = _PyPegen_expect_token(p, 525))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , IsNot , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// is_bitwise_or: 'is' bitwise_or
static CmpopExprPair*
is_bitwise_or_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    CmpopExprPair* res = NULL;
    int mark = p->mark;
    { // 'is' bitwise_or
        expr_ty a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 526))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_cmpop_expr_pair ( p , Is , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// Left-recursive
// bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
static expr_ty bitwise_or_raw(Parser *);
static expr_ty
bitwise_or_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_or_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_1 = _PyPegen_update_memo(p, mark, bitwise_or_type, res);
        if (tmpvar_1) {
            return res;
        }
        p->mark = mark;
        void *raw = bitwise_or_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
bitwise_or_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // bitwise_or '|' bitwise_xor
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = bitwise_or_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 18))
            &&
            (b = bitwise_xor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , BitOr , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // bitwise_xor
        expr_ty bitwise_xor_var;
        if (
            (bitwise_xor_var = bitwise_xor_rule(p))
        )
        {
            res = bitwise_xor_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// Left-recursive
// bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
static expr_ty bitwise_xor_raw(Parser *);
static expr_ty
bitwise_xor_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_xor_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_2 = _PyPegen_update_memo(p, mark, bitwise_xor_type, res);
        if (tmpvar_2) {
            return res;
        }
        p->mark = mark;
        void *raw = bitwise_xor_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
bitwise_xor_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // bitwise_xor '^' bitwise_and
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = bitwise_xor_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 32))
            &&
            (b = bitwise_and_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , BitXor , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // bitwise_and
        expr_ty bitwise_and_var;
        if (
            (bitwise_and_var = bitwise_and_rule(p))
        )
        {
            res = bitwise_and_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// Left-recursive
// bitwise_and: bitwise_and '&' shift_expr | shift_expr
static expr_ty bitwise_and_raw(Parser *);
static expr_ty
bitwise_and_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_and_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_3 = _PyPegen_update_memo(p, mark, bitwise_and_type, res);
        if (tmpvar_3) {
            return res;
        }
        p->mark = mark;
        void *raw = bitwise_and_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
bitwise_and_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // bitwise_and '&' shift_expr
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = bitwise_and_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 19))
            &&
            (b = shift_expr_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , BitAnd , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // shift_expr
        expr_ty shift_expr_var;
        if (
            (shift_expr_var = shift_expr_rule(p))
        )
        {
            res = shift_expr_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// Left-recursive
// shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
static expr_ty shift_expr_raw(Parser *);
static expr_ty
shift_expr_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, shift_expr_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_4 = _PyPegen_update_memo(p, mark, shift_expr_type, res);
        if (tmpvar_4) {
            return res;
        }
        p->mark = mark;
        void *raw = shift_expr_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
shift_expr_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // shift_expr '<<' sum
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = shift_expr_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 33))
            &&
            (b = sum_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , LShift , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // shift_expr '>>' sum
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = shift_expr_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 34))
            &&
            (b = sum_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , RShift , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // sum
        expr_ty sum_var;
        if (
            (sum_var = sum_rule(p))
        )
        {
            res = sum_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// Left-recursive
// sum: sum '+' term | sum '-' term | term
static expr_ty sum_raw(Parser *);
static expr_ty
sum_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, sum_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_5 = _PyPegen_update_memo(p, mark, sum_type, res);
        if (tmpvar_5) {
            return res;
        }
        p->mark = mark;
        void *raw = sum_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
sum_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // sum '+' term
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = sum_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 14))
            &&
            (b = term_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , Add , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // sum '-' term
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = sum_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 15))
            &&
            (b = term_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , Sub , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // term
        expr_ty term_var;
        if (
            (term_var = term_rule(p))
        )
        {
            res = term_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// Left-recursive
// term:
//     | term '*' factor
//     | term '/' factor
//     | term '//' factor
//     | term '%' factor
//     | term '@' factor
//     | factor
static expr_ty term_raw(Parser *);
static expr_ty
term_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, term_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_6 = _PyPegen_update_memo(p, mark, term_type, res);
        if (tmpvar_6) {
            return res;
        }
        p->mark = mark;
        void *raw = term_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
term_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // term '*' factor
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = term_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (b = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , Mult , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // term '/' factor
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = term_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 17))
            &&
            (b = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , Div , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // term '//' factor
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = term_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 47))
            &&
            (b = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , FloorDiv , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // term '%' factor
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = term_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 24))
            &&
            (b = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , Mod , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // term '@' factor
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = term_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 49))
            &&
            (b = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , MatMult , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // factor
        expr_ty factor_var;
        if (
            (factor_var = factor_rule(p))
        )
        {
            res = factor_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// factor: '+' factor | '-' factor | '~' factor | power
static expr_ty
factor_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, factor_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '+' factor
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 14))
            &&
            (a = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_UnaryOp ( UAdd , a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '-' factor
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 15))
            &&
            (a = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_UnaryOp ( USub , a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '~' factor
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 31))
            &&
            (a = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_UnaryOp ( Invert , a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // power
        expr_ty power_var;
        if (
            (power_var = power_rule(p))
        )
        {
            res = power_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, factor_type, res);
    return res;
}

// power: await_primary '**' factor | await_primary
static expr_ty
power_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // await_primary '**' factor
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = await_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 35))
            &&
            (b = factor_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_BinOp ( a , Pow , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // await_primary
        expr_ty await_primary_var;
        if (
            (await_primary_var = await_primary_rule(p))
        )
        {
            res = await_primary_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// await_primary: AWAIT primary | primary
static expr_ty
await_primary_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, await_primary_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // AWAIT primary
        expr_ty a;
        void *await_var;
        if (
            (await_var = _PyPegen_await_token(p))
            &&
            (a = primary_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Await ( a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // primary
        expr_ty primary_var;
        if (
            (primary_var = primary_rule(p))
        )
        {
            res = primary_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, await_primary_type, res);
    return res;
}

// Left-recursive
// primary:
//     | primary '.' NAME
//     | primary genexp
//     | primary '(' arguments? ')'
//     | primary '[' slices ']'
//     | atom
static expr_ty primary_raw(Parser *);
static expr_ty
primary_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, primary_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_7 = _PyPegen_update_memo(p, mark, primary_type, res);
        if (tmpvar_7) {
            return res;
        }
        p->mark = mark;
        void *raw = primary_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
primary_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // primary '.' NAME
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 23))
            &&
            (b = _PyPegen_name_token(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Attribute ( a , b -> v . Name . id , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // primary genexp
        expr_ty a;
        expr_ty b;
        if (
            (a = primary_rule(p))
            &&
            (b = genexp_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Call ( a , CHECK ( _PyPegen_singleton_seq ( p , b ) ) , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // primary '(' arguments? ')'
        expr_ty a;
        void *b;
        void *literal;
        void *literal_1;
        if (
            (a = primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (b = arguments_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Call ( a , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // primary '[' slices ']'
        expr_ty a;
        expr_ty b;
        void *literal;
        void *literal_1;
        if (
            (a = primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (b = slices_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Subscript ( a , b , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // atom
        expr_ty atom_var;
        if (
            (atom_var = atom_rule(p))
        )
        {
            res = atom_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// slices: slice !',' | ','.slice+ ','?
static expr_ty
slices_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // slice !','
        expr_ty a;
        if (
            (a = slice_rule(p))
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // ','.slice+ ','?
        asdl_seq * a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = _gather_86_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( a , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// slice: expression? ':' expression? [':' expression?] | expression
static expr_ty
slice_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // expression? ':' expression? [':' expression?]
        void *a;
        void *b;
        void *c;
        void *literal;
        if (
            (a = expression_rule(p), 1)
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = expression_rule(p), 1)
            &&
            (c = _tmp_88_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Slice ( a , b , c , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression
        expr_ty a;
        if (
            (a = expression_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// atom:
//     | NAME
//     | 'True'
//     | 'False'
//     | 'None'
//     | '__new_parser__'
//     | &STRING strings
//     | NUMBER
//     | &'(' (tuple | group | genexp)
//     | &'[' (list | listcomp)
//     | &'{' (dict | set | dictcomp | setcomp)
//     | '...'
static expr_ty
atom_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))
        )
        {
            res = name_var;
            goto done;
        }
        p->mark = mark;
    }
    { // 'True'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 527))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Constant ( Py_True , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'False'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 528))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Constant ( Py_False , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'None'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 529))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Constant ( Py_None , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '__new_parser__'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 530))
        )
        {
            res = RAISE_SYNTAX_ERROR ( "You found it!" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // &STRING strings
        expr_ty strings_var;
        if (
            _PyPegen_lookahead(1, _PyPegen_string_token, p)
            &&
            (strings_var = strings_rule(p))
        )
        {
            res = strings_var;
            goto done;
        }
        p->mark = mark;
    }
    { // NUMBER
        expr_ty number_var;
        if (
            (number_var = _PyPegen_number_token(p))
        )
        {
            res = number_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'(' (tuple | group | genexp)
        void *_tmp_89_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 7)
            &&
            (_tmp_89_var = _tmp_89_rule(p))
        )
        {
            res = _tmp_89_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'[' (list | listcomp)
        void *_tmp_90_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 9)
            &&
            (_tmp_90_var = _tmp_90_rule(p))
        )
        {
            res = _tmp_90_var;
            goto done;
        }
        p->mark = mark;
    }
    { // &'{' (dict | set | dictcomp | setcomp)
        void *_tmp_91_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 25)
            &&
            (_tmp_91_var = _tmp_91_rule(p))
        )
        {
            res = _tmp_91_var;
            goto done;
        }
        p->mark = mark;
    }
    { // '...'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 52))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Constant ( Py_Ellipsis , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// strings: STRING+
static expr_ty
strings_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, strings_type, &res))
        return res;
    int mark = p->mark;
    { // STRING+
        asdl_seq * a;
        if (
            (a = _loop1_92_rule(p))
        )
        {
            res = _PyPegen_concatenate_strings ( p , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, strings_type, res);
    return res;
}

// list: '[' star_named_expressions? ']'
static expr_ty
list_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '[' star_named_expressions? ']'
        void *a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (a = star_named_expressions_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_List ( a , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension
static expr_ty
listcomp_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '[' named_expression for_if_clauses ']'
        expr_ty a;
        asdl_seq* b;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (a = named_expression_rule(p))
            &&
            (b = for_if_clauses_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_ListComp ( a , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // invalid_comprehension
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))
        )
        {
            res = invalid_comprehension_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
static expr_ty
tuple_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '(' [star_named_expression ',' star_named_expressions?] ')'
        void *a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = _tmp_93_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( a , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// group: '(' (yield_expr | named_expression) ')'
static expr_ty
group_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    { // '(' (yield_expr | named_expression) ')'
        void *a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = _tmp_94_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// genexp: '(' expression for_if_clauses ')' | invalid_comprehension
static expr_ty
genexp_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '(' expression for_if_clauses ')'
        expr_ty a;
        asdl_seq* b;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = expression_rule(p))
            &&
            (b = for_if_clauses_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_GeneratorExp ( a , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // invalid_comprehension
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))
        )
        {
            res = invalid_comprehension_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// set: '{' expressions_list '}'
static expr_ty
set_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '{' expressions_list '}'
        asdl_seq* a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 25))
            &&
            (a = expressions_list_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 26))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Set ( a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// setcomp: '{' expression for_if_clauses '}' | invalid_comprehension
static expr_ty
setcomp_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '{' expression for_if_clauses '}'
        expr_ty a;
        asdl_seq* b;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 25))
            &&
            (a = expression_rule(p))
            &&
            (b = for_if_clauses_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 26))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_SetComp ( a , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // invalid_comprehension
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))
        )
        {
            res = invalid_comprehension_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// dict: '{' kvpairs? '}'
static expr_ty
dict_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '{' kvpairs? '}'
        void *a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 25))
            &&
            (a = kvpairs_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 26))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Dict ( CHECK ( _PyPegen_get_keys ( p , a ) ) , CHECK ( _PyPegen_get_values ( p , a ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// dictcomp: '{' kvpair for_if_clauses '}'
static expr_ty
dictcomp_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '{' kvpair for_if_clauses '}'
        KeyValuePair* a;
        asdl_seq* b;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 25))
            &&
            (a = kvpair_rule(p))
            &&
            (b = for_if_clauses_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 26))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_DictComp ( a -> key , a -> value , b , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// kvpairs: ','.kvpair+ ','?
static asdl_seq*
kvpairs_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.kvpair+ ','?
        asdl_seq * a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = _gather_95_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// kvpair: '**' bitwise_or | expression ':' expression
static KeyValuePair*
kvpair_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    KeyValuePair* res = NULL;
    int mark = p->mark;
    { // '**' bitwise_or
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 35))
            &&
            (a = bitwise_or_rule(p))
        )
        {
            res = _PyPegen_key_value_pair ( p , NULL , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression ':' expression
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (b = expression_rule(p))
        )
        {
            res = _PyPegen_key_value_pair ( p , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// for_if_clauses: ((ASYNC? 'for' star_targets 'in' disjunction (('if' disjunction))*))+
static asdl_seq*
for_if_clauses_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ((ASYNC? 'for' star_targets 'in' disjunction (('if' disjunction))*))+
        asdl_seq * a;
        if (
            (a = _loop1_97_rule(p))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
static expr_ty
yield_expr_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // 'yield' 'from' expression
        expr_ty a;
        void *keyword;
        void *keyword_1;
        if (
            (keyword = _PyPegen_expect_token(p, 504))
            &&
            (keyword_1 = _PyPegen_expect_token(p, 514))
            &&
            (a = expression_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_YieldFrom ( a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // 'yield' star_expressions?
        void *a;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 504))
            &&
            (a = star_expressions_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Yield ( a , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// arguments: args ','? &')' | incorrect_arguments
static expr_ty
arguments_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, arguments_type, &res))
        return res;
    int mark = p->mark;
    { // args ','? &')'
        expr_ty a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = args_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // incorrect_arguments
        void *incorrect_arguments_var;
        if (
            (incorrect_arguments_var = incorrect_arguments_rule(p))
        )
        {
            res = incorrect_arguments_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, arguments_type, res);
    return res;
}

// args: starred_expression [',' args] | kwargs | named_expression [',' args]
static expr_ty
args_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // starred_expression [',' args]
        expr_ty a;
        void *b;
        if (
            (a = starred_expression_rule(p))
            &&
            (b = _tmp_98_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Call ( _PyPegen_dummy_name ( p ) , ( b ) ? CHECK ( _PyPegen_seq_insert_in_front ( p , a , ( ( expr_ty ) b ) -> v . Call . args ) ) : CHECK ( _PyPegen_singleton_seq ( p , a ) ) , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // kwargs
        asdl_seq* a;
        if (
            (a = kwargs_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Call ( _PyPegen_dummy_name ( p ) , CHECK_NULL_ALLOWED ( _PyPegen_seq_extract_starred_exprs ( p , a ) ) , CHECK_NULL_ALLOWED ( _PyPegen_seq_delete_starred_exprs ( p , a ) ) , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // named_expression [',' args]
        expr_ty a;
        void *b;
        if (
            (a = named_expression_rule(p))
            &&
            (b = _tmp_99_rule(p), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Call ( _PyPegen_dummy_name ( p ) , ( b ) ? CHECK ( _PyPegen_seq_insert_in_front ( p , a , ( ( expr_ty ) b ) -> v . Call . args ) ) : CHECK ( _PyPegen_singleton_seq ( p , a ) ) , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// kwargs:
//     | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+
//     | ','.kwarg_or_starred+
//     | ','.kwarg_or_double_starred+
static asdl_seq*
kwargs_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+
        asdl_seq * a;
        asdl_seq * b;
        void *literal;
        if (
            (a = _gather_100_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (b = _gather_102_rule(p))
        )
        {
            res = _PyPegen_join_sequences ( p , a , b );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // ','.kwarg_or_starred+
        asdl_seq * _gather_104_var;
        if (
            (_gather_104_var = _gather_104_rule(p))
        )
        {
            res = _gather_104_var;
            goto done;
        }
        p->mark = mark;
    }
    { // ','.kwarg_or_double_starred+
        asdl_seq * _gather_106_var;
        if (
            (_gather_106_var = _gather_106_rule(p))
        )
        {
            res = _gather_106_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// starred_expression: '*' expression
static expr_ty
starred_expression_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '*' expression
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (a = expression_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Starred ( a , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// kwarg_or_starred: NAME '=' expression | starred_expression
static KeywordOrStarred*
kwarg_or_starred_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    KeywordOrStarred* res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME '=' expression
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = _PyPegen_name_token(p))
            &&
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (b = expression_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( a -> v . Name . id , b , EXTRA ) ) , 1 );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // starred_expression
        expr_ty a;
        if (
            (a = starred_expression_rule(p))
        )
        {
            res = _PyPegen_keyword_or_starred ( p , a , 0 );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// kwarg_or_double_starred: NAME '=' expression | '**' expression
static KeywordOrStarred*
kwarg_or_double_starred_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    KeywordOrStarred* res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME '=' expression
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = _PyPegen_name_token(p))
            &&
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (b = expression_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( a -> v . Name . id , b , EXTRA ) ) , 1 );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '**' expression
        expr_ty a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 35))
            &&
            (a = expression_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _PyPegen_keyword_or_starred ( p , CHECK ( _Py_keyword ( NULL , a , EXTRA ) ) , 1 );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// star_targets: star_target !',' | star_target ((',' star_target))* ','?
static expr_ty
star_targets_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // star_target !','
        expr_ty a;
        if (
            (a = star_target_rule(p))
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // star_target ((',' star_target))* ','?
        expr_ty a;
        asdl_seq * b;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = star_target_rule(p))
            &&
            (b = _loop0_108_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( CHECK ( _PyPegen_seq_insert_in_front ( p , a , b ) ) , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// star_targets_seq: ','.star_target+ ','?
static asdl_seq*
star_targets_seq_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.star_target+ ','?
        asdl_seq * a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = _gather_109_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// star_target:
//     | '*' (!'*' star_target)
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
//     | star_atom
static expr_ty
star_target_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, star_target_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // '*' (!'*' star_target)
        void *a;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (a = _tmp_111_rule(p))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Starred ( CHECK ( _PyPegen_set_expr_context ( p , a , Store ) ) , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_primary '.' NAME !t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 23))
            &&
            (b = _PyPegen_name_token(p))
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Attribute ( a , b -> v . Name . id , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_primary '[' slices ']' !t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        void *literal_1;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (b = slices_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Subscript ( a , b , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // star_atom
        expr_ty star_atom_var;
        if (
            (star_atom_var = star_atom_rule(p))
        )
        {
            res = star_atom_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, star_target_type, res);
    return res;
}

// star_atom:
//     | NAME
//     | '(' star_target ')'
//     | '(' star_targets_seq? ')'
//     | '[' star_targets_seq? ']'
static expr_ty
star_atom_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))
        )
        {
            res = _PyPegen_set_expr_context ( p , a , Store );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '(' star_target ')'
        expr_ty a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = star_target_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            res = _PyPegen_set_expr_context ( p , a , Store );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '(' star_targets_seq? ')'
        void *a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = star_targets_seq_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( a , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '[' star_targets_seq? ']'
        void *a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (a = star_targets_seq_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_List ( a , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// inside_paren_ann_assign_target:
//     | ann_assign_subscript_attribute_target
//     | NAME
//     | '(' inside_paren_ann_assign_target ')'
static expr_ty
inside_paren_ann_assign_target_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    { // ann_assign_subscript_attribute_target
        expr_ty ann_assign_subscript_attribute_target_var;
        if (
            (ann_assign_subscript_attribute_target_var = ann_assign_subscript_attribute_target_rule(p))
        )
        {
            res = ann_assign_subscript_attribute_target_var;
            goto done;
        }
        p->mark = mark;
    }
    { // NAME
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))
        )
        {
            res = _PyPegen_set_expr_context ( p , a , Store );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '(' inside_paren_ann_assign_target ')'
        expr_ty a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = inside_paren_ann_assign_target_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// ann_assign_subscript_attribute_target:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
static expr_ty
ann_assign_subscript_attribute_target_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // t_primary '.' NAME !t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 23))
            &&
            (b = _PyPegen_name_token(p))
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Attribute ( a , b -> v . Name . id , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_primary '[' slices ']' !t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        void *literal_1;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (b = slices_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Subscript ( a , b , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// del_targets: ','.del_target+ ','?
static asdl_seq*
del_targets_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.del_target+ ','?
        asdl_seq * a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = _gather_112_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// del_target:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
//     | del_t_atom
static expr_ty
del_target_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, del_target_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // t_primary '.' NAME !t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 23))
            &&
            (b = _PyPegen_name_token(p))
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Attribute ( a , b -> v . Name . id , Del , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_primary '[' slices ']' !t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        void *literal_1;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (b = slices_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Subscript ( a , b , Del , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // del_t_atom
        expr_ty del_t_atom_var;
        if (
            (del_t_atom_var = del_t_atom_rule(p))
        )
        {
            res = del_t_atom_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, del_target_type, res);
    return res;
}

// del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
static expr_ty
del_t_atom_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))
        )
        {
            res = _PyPegen_set_expr_context ( p , a , Del );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '(' del_target ')'
        expr_ty a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = del_target_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            res = _PyPegen_set_expr_context ( p , a , Del );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '(' del_targets? ')'
        void *a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = del_targets_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( a , Del , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '[' del_targets? ']'
        void *a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (a = del_targets_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_List ( a , Del , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// targets: ','.target+ ','?
static asdl_seq*
targets_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq* res = NULL;
    int mark = p->mark;
    { // ','.target+ ','?
        asdl_seq * a;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (a = _gather_114_rule(p))
            &&
            (opt_var = _PyPegen_expect_token(p, 12), 1)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// target:
//     | t_primary '.' NAME !t_lookahead
//     | t_primary '[' slices ']' !t_lookahead
//     | t_atom
static expr_ty
target_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, target_type, &res))
        return res;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // t_primary '.' NAME !t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 23))
            &&
            (b = _PyPegen_name_token(p))
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Attribute ( a , b -> v . Name . id , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_primary '[' slices ']' !t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        void *literal_1;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (b = slices_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Subscript ( a , b , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_atom
        expr_ty t_atom_var;
        if (
            (t_atom_var = t_atom_rule(p))
        )
        {
            res = t_atom_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    _PyPegen_insert_memo(p, mark, target_type, res);
    return res;
}

// Left-recursive
// t_primary:
//     | t_primary '.' NAME &t_lookahead
//     | t_primary '[' slices ']' &t_lookahead
//     | t_primary genexp &t_lookahead
//     | t_primary '(' arguments? ')' &t_lookahead
//     | atom &t_lookahead
static expr_ty t_primary_raw(Parser *);
static expr_ty
t_primary_rule(Parser *p)
{
    expr_ty res = NULL;
    if (_PyPegen_is_memoized(p, t_primary_type, &res))
        return res;
    int mark = p->mark;
    int resmark = p->mark;
    while (1) {
        int tmpvar_8 = _PyPegen_update_memo(p, mark, t_primary_type, res);
        if (tmpvar_8) {
            return res;
        }
        p->mark = mark;
        void *raw = t_primary_raw(p);
        if (raw == NULL || p->mark <= resmark)
            break;
        resmark = p->mark;
        res = raw;
    }
    p->mark = resmark;
    return res;
}
static expr_ty
t_primary_raw(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // t_primary '.' NAME &t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 23))
            &&
            (b = _PyPegen_name_token(p))
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Attribute ( a , b -> v . Name . id , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_primary '[' slices ']' &t_lookahead
        expr_ty a;
        expr_ty b;
        void *literal;
        void *literal_1;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (b = slices_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Subscript ( a , b , Load , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_primary genexp &t_lookahead
        expr_ty a;
        expr_ty b;
        if (
            (a = t_primary_rule(p))
            &&
            (b = genexp_rule(p))
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Call ( a , CHECK ( _PyPegen_singleton_seq ( p , b ) ) , NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // t_primary '(' arguments? ')' &t_lookahead
        expr_ty a;
        void *b;
        void *literal;
        void *literal_1;
        if (
            (a = t_primary_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (b = arguments_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Call ( a , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // atom &t_lookahead
        expr_ty a;
        if (
            (a = atom_rule(p))
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            res = a;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// t_lookahead: '(' | '[' | '.'
static void *
t_lookahead_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '('
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 7))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    { // '['
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 9))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    { // '.'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 23))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// t_atom: NAME | '(' target ')' | '(' targets? ')' | '[' targets? ']'
static expr_ty
t_atom_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    expr_ty res = NULL;
    int mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        return NULL;
    }
    int start_lineno = p->tokens[mark]->lineno;
    UNUSED(start_lineno); // Only used by EXTRA macro
    int start_col_offset = p->tokens[mark]->col_offset;
    UNUSED(start_col_offset); // Only used by EXTRA macro
    { // NAME
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))
        )
        {
            res = _PyPegen_set_expr_context ( p , a , Store );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '(' target ')'
        expr_ty a;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (a = target_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            res = _PyPegen_set_expr_context ( p , a , Store );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '(' targets? ')'
        void *b;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (b = targets_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_Tuple ( b , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // '[' targets? ']'
        void *b;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 9))
            &&
            (b = targets_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 10))
        )
        {
            Token *token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (token == NULL) {
                return NULL;
            }
            int end_lineno = token->end_lineno;
            UNUSED(end_lineno); // Only used by EXTRA macro
            int end_col_offset = token->end_col_offset;
            UNUSED(end_col_offset); // Only used by EXTRA macro
            res = _Py_List ( b , Store , EXTRA );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// incorrect_arguments:
//     | args ',' '*'
//     | expression for_if_clauses ',' [args | expression for_if_clauses]
//     | args ',' args
static void *
incorrect_arguments_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // args ',' '*'
        expr_ty args_var;
        void *literal;
        void *literal_1;
        if (
            (args_var = args_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (literal_1 = _PyPegen_expect_token(p, 16))
        )
        {
            res = RAISE_SYNTAX_ERROR ( "iterable argument unpacking follows keyword argument unpacking" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression for_if_clauses ',' [args | expression for_if_clauses]
        expr_ty expression_var;
        asdl_seq* for_if_clauses_var;
        void *literal;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (expression_var = expression_rule(p))
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (opt_var = _tmp_116_rule(p), 1)
        )
        {
            res = RAISE_SYNTAX_ERROR ( "Generator expression must be parenthesized" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // args ',' args
        expr_ty a;
        expr_ty args_var;
        void *literal;
        if (
            (a = args_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (args_var = args_rule(p))
        )
        {
            res = _PyPegen_arguments_parsing_error ( p , a );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// invalid_named_expression: expression ':=' expression
static void *
invalid_named_expression_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // expression ':=' expression
        expr_ty a;
        expr_ty expression_var;
        void *literal;
        if (
            (a = expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 53))
            &&
            (expression_var = expression_rule(p))
        )
        {
            res = RAISE_SYNTAX_ERROR ( "cannot use assignment expressions with %s" , _PyPegen_get_expr_name ( a ) );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// invalid_assignment:
//     | list ':'
//     | tuple ':'
//     | expression ':' expression ['=' annotated_rhs]
//     | expression ('=' | augassign) (yield_expr | star_expressions)
static void *
invalid_assignment_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // list ':'
        expr_ty list_var;
        void *literal;
        if (
            (list_var = list_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
        )
        {
            res = RAISE_SYNTAX_ERROR ( "only single target (not list) can be annotated" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // tuple ':'
        void *literal;
        expr_ty tuple_var;
        if (
            (tuple_var = tuple_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
        )
        {
            res = RAISE_SYNTAX_ERROR ( "only single target (not tuple) can be annotated" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression ':' expression ['=' annotated_rhs]
        expr_ty expression_var;
        expr_ty expression_var_1;
        void *literal;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        if (
            (expression_var = expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (expression_var_1 = expression_rule(p))
            &&
            (opt_var = _tmp_117_rule(p), 1)
        )
        {
            res = RAISE_SYNTAX_ERROR ( "illegal target for annotation" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // expression ('=' | augassign) (yield_expr | star_expressions)
        void *_tmp_118_var;
        void *_tmp_119_var;
        expr_ty a;
        if (
            (a = expression_rule(p))
            &&
            (_tmp_118_var = _tmp_118_rule(p))
            &&
            (_tmp_119_var = _tmp_119_rule(p))
        )
        {
            res = RAISE_SYNTAX_ERROR ( "cannot assign to %s" , _PyPegen_get_expr_name ( a ) );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// invalid_block: NEWLINE !INDENT
static void *
invalid_block_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // NEWLINE !INDENT
        void *newline_var;
        if (
            (newline_var = _PyPegen_newline_token(p))
            &&
            _PyPegen_lookahead(0, _PyPegen_indent_token, p)
        )
        {
            res = RAISE_INDENTATION_ERROR ( "expected an indented block" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// invalid_comprehension: ('[' | '(' | '{') '*' expression for_if_clauses
static void *
invalid_comprehension_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ('[' | '(' | '{') '*' expression for_if_clauses
        void *_tmp_120_var;
        expr_ty expression_var;
        asdl_seq* for_if_clauses_var;
        void *literal;
        if (
            (_tmp_120_var = _tmp_120_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 16))
            &&
            (expression_var = expression_rule(p))
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))
        )
        {
            res = RAISE_SYNTAX_ERROR ( "iterable unpacking cannot be used in comprehension" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// invalid_parameters:
//     | [plain_names ','] (slash_with_default | names_with_default) ',' plain_names
static void *
invalid_parameters_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // [plain_names ','] (slash_with_default | names_with_default) ',' plain_names
        void *_tmp_122_var;
        void *literal;
        void *opt_var;
        UNUSED(opt_var); // Silence compiler warnings
        asdl_seq* plain_names_var;
        if (
            (opt_var = _tmp_121_rule(p), 1)
            &&
            (_tmp_122_var = _tmp_122_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (plain_names_var = plain_names_rule(p))
        )
        {
            res = RAISE_SYNTAX_ERROR ( "non-default argument follows default argument" );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_1: NEWLINE
static asdl_seq *
_loop0_1_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // NEWLINE
        void *newline_var;
        while (
            (newline_var = _PyPegen_newline_token(p))
        )
        {
            res = newline_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_1");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_1_type, seq);
    return seq;
}

// _loop1_2: statement
static asdl_seq *
_loop1_2_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // statement
        asdl_seq* statement_var;
        while (
            (statement_var = statement_rule(p))
        )
        {
            res = statement_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_2");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_2_type, seq);
    return seq;
}

// _loop0_4: ';' small_stmt
static asdl_seq *
_loop0_4_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ';' small_stmt
        stmt_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 13))
            &&
            (elem = small_stmt_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_4");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_4_type, seq);
    return seq;
}

// _gather_3: small_stmt _loop0_4
static asdl_seq *
_gather_3_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // small_stmt _loop0_4
        stmt_ty elem;
        asdl_seq * seq;
        if (
            (elem = small_stmt_rule(p))
            &&
            (seq = _loop0_4_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_5: 'import' | 'from'
static void *
_tmp_5_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'import'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 513))
        )
        {
            res = keyword;
            goto done;
        }
        p->mark = mark;
    }
    { // 'from'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 514))
        )
        {
            res = keyword;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_6: 'def' | '@' | ASYNC
static void *
_tmp_6_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'def'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 522))
        )
        {
            res = keyword;
            goto done;
        }
        p->mark = mark;
    }
    { // '@'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 49))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    { // ASYNC
        void *async_var;
        if (
            (async_var = _PyPegen_async_token(p))
        )
        {
            res = async_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_7: 'class' | '@'
static void *
_tmp_7_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'class'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 523))
        )
        {
            res = keyword;
            goto done;
        }
        p->mark = mark;
    }
    { // '@'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 49))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_8: 'with' | ASYNC
static void *
_tmp_8_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'with'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 519))
        )
        {
            res = keyword;
            goto done;
        }
        p->mark = mark;
    }
    { // ASYNC
        void *async_var;
        if (
            (async_var = _PyPegen_async_token(p))
        )
        {
            res = async_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_9: 'for' | ASYNC
static void *
_tmp_9_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'for'
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 517))
        )
        {
            res = keyword;
            goto done;
        }
        p->mark = mark;
    }
    { // ASYNC
        void *async_var;
        if (
            (async_var = _PyPegen_async_token(p))
        )
        {
            res = async_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_10: '=' annotated_rhs
static void *
_tmp_10_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '=' annotated_rhs
        expr_ty d;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (d = annotated_rhs_rule(p))
        )
        {
            res = d;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_11: '(' inside_paren_ann_assign_target ')' | ann_assign_subscript_attribute_target
static void *
_tmp_11_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '(' inside_paren_ann_assign_target ')'
        expr_ty b;
        void *literal;
        void *literal_1;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (b = inside_paren_ann_assign_target_rule(p))
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            res = b;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    { // ann_assign_subscript_attribute_target
        expr_ty ann_assign_subscript_attribute_target_var;
        if (
            (ann_assign_subscript_attribute_target_var = ann_assign_subscript_attribute_target_rule(p))
        )
        {
            res = ann_assign_subscript_attribute_target_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_12: '=' annotated_rhs
static void *
_tmp_12_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '=' annotated_rhs
        expr_ty d;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (d = annotated_rhs_rule(p))
        )
        {
            res = d;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_13: (star_targets '=')
static asdl_seq *
_loop1_13_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // (star_targets '=')
        void *_tmp_123_var;
        while (
            (_tmp_123_var = _tmp_123_rule(p))
        )
        {
            res = _tmp_123_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_13");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_13_type, seq);
    return seq;
}

// _tmp_14: yield_expr | star_expressions
static void *
_tmp_14_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // yield_expr
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))
        )
        {
            res = yield_expr_var;
            goto done;
        }
        p->mark = mark;
    }
    { // star_expressions
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))
        )
        {
            res = star_expressions_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_15: yield_expr | star_expressions
static void *
_tmp_15_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // yield_expr
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))
        )
        {
            res = yield_expr_var;
            goto done;
        }
        p->mark = mark;
    }
    { // star_expressions
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))
        )
        {
            res = star_expressions_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_17: ',' NAME
static asdl_seq *
_loop0_17_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' NAME
        expr_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = _PyPegen_name_token(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_17");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_17_type, seq);
    return seq;
}

// _gather_16: NAME _loop0_17
static asdl_seq *
_gather_16_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // NAME _loop0_17
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = _PyPegen_name_token(p))
            &&
            (seq = _loop0_17_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_19: ',' NAME
static asdl_seq *
_loop0_19_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' NAME
        expr_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = _PyPegen_name_token(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_19");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_19_type, seq);
    return seq;
}

// _gather_18: NAME _loop0_19
static asdl_seq *
_gather_18_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // NAME _loop0_19
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = _PyPegen_name_token(p))
            &&
            (seq = _loop0_19_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_20: ',' expression
static void *
_tmp_20_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' expression
        void *literal;
        expr_ty z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = expression_rule(p))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_21: ('.' | '...')
static asdl_seq *
_loop0_21_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ('.' | '...')
        void *_tmp_124_var;
        while (
            (_tmp_124_var = _tmp_124_rule(p))
        )
        {
            res = _tmp_124_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_21");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_21_type, seq);
    return seq;
}

// _loop1_22: ('.' | '...')
static asdl_seq *
_loop1_22_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ('.' | '...')
        void *_tmp_125_var;
        while (
            (_tmp_125_var = _tmp_125_rule(p))
        )
        {
            res = _tmp_125_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_22");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_22_type, seq);
    return seq;
}

// _loop0_24: ',' import_from_as_name
static asdl_seq *
_loop0_24_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' import_from_as_name
        alias_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = import_from_as_name_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_24");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_24_type, seq);
    return seq;
}

// _gather_23: import_from_as_name _loop0_24
static asdl_seq *
_gather_23_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // import_from_as_name _loop0_24
        alias_ty elem;
        asdl_seq * seq;
        if (
            (elem = import_from_as_name_rule(p))
            &&
            (seq = _loop0_24_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_25: 'as' NAME
static void *
_tmp_25_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'as' NAME
        void *keyword;
        expr_ty z;
        if (
            (keyword = _PyPegen_expect_token(p, 531))
            &&
            (z = _PyPegen_name_token(p))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_27: ',' dotted_as_name
static asdl_seq *
_loop0_27_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' dotted_as_name
        alias_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = dotted_as_name_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_27");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_27_type, seq);
    return seq;
}

// _gather_26: dotted_as_name _loop0_27
static asdl_seq *
_gather_26_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // dotted_as_name _loop0_27
        alias_ty elem;
        asdl_seq * seq;
        if (
            (elem = dotted_as_name_rule(p))
            &&
            (seq = _loop0_27_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_28: 'as' NAME
static void *
_tmp_28_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'as' NAME
        void *keyword;
        expr_ty z;
        if (
            (keyword = _PyPegen_expect_token(p, 531))
            &&
            (z = _PyPegen_name_token(p))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_30: ',' with_item
static asdl_seq *
_loop0_30_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' with_item
        withitem_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = with_item_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_30");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_30_type, seq);
    return seq;
}

// _gather_29: with_item _loop0_30
static asdl_seq *
_gather_29_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // with_item _loop0_30
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))
            &&
            (seq = _loop0_30_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_32: ',' with_item
static asdl_seq *
_loop0_32_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' with_item
        withitem_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = with_item_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_32");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_32_type, seq);
    return seq;
}

// _gather_31: with_item _loop0_32
static asdl_seq *
_gather_31_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // with_item _loop0_32
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))
            &&
            (seq = _loop0_32_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_33: 'as' target
static void *
_tmp_33_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'as' target
        void *keyword;
        expr_ty t;
        if (
            (keyword = _PyPegen_expect_token(p, 531))
            &&
            (t = target_rule(p))
        )
        {
            res = t;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_34: except_block
static asdl_seq *
_loop1_34_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // except_block
        excepthandler_ty except_block_var;
        while (
            (except_block_var = except_block_rule(p))
        )
        {
            res = except_block_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_34");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_34_type, seq);
    return seq;
}

// _tmp_35: 'as' target
static void *
_tmp_35_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'as' target
        void *keyword;
        expr_ty z;
        if (
            (keyword = _PyPegen_expect_token(p, 531))
            &&
            (z = target_rule(p))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_36: 'from' expression
static void *
_tmp_36_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'from' expression
        void *keyword;
        expr_ty z;
        if (
            (keyword = _PyPegen_expect_token(p, 514))
            &&
            (z = expression_rule(p))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_37: '->' annotation
static void *
_tmp_37_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '->' annotation
        void *literal;
        expr_ty z;
        if (
            (literal = _PyPegen_expect_token(p, 51))
            &&
            (z = annotation_rule(p))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_38: ',' plain_names
static void *
_tmp_38_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' plain_names
        void *literal;
        asdl_seq* x;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (x = plain_names_rule(p))
        )
        {
            res = x;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_39: ',' names_with_default
static void *
_tmp_39_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' names_with_default
        void *literal;
        asdl_seq* y;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (y = names_with_default_rule(p))
        )
        {
            res = y;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_40: ',' star_etc?
static void *
_tmp_40_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' star_etc?
        void *literal;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = star_etc_rule(p), 1)
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_41: ',' names_with_default
static void *
_tmp_41_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' names_with_default
        void *literal;
        asdl_seq* y;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (y = names_with_default_rule(p))
        )
        {
            res = y;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_42: ',' star_etc?
static void *
_tmp_42_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' star_etc?
        void *literal;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = star_etc_rule(p), 1)
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_43: ',' names_with_default
static void *
_tmp_43_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' names_with_default
        void *literal;
        asdl_seq* y;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (y = names_with_default_rule(p))
        )
        {
            res = y;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_44: ',' star_etc?
static void *
_tmp_44_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' star_etc?
        void *literal;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = star_etc_rule(p), 1)
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_45: ',' star_etc?
static void *
_tmp_45_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' star_etc?
        void *literal;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = star_etc_rule(p), 1)
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_46: plain_names ','
static void *
_tmp_46_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // plain_names ','
        void *literal;
        asdl_seq* n;
        if (
            (n = plain_names_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
        )
        {
            res = n;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_47: name_with_optional_default
static asdl_seq *
_loop0_47_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // name_with_optional_default
        NameDefaultPair* name_with_optional_default_var;
        while (
            (name_with_optional_default_var = name_with_optional_default_rule(p))
        )
        {
            res = name_with_optional_default_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_47");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_47_type, seq);
    return seq;
}

// _tmp_48: ',' kwds
static void *
_tmp_48_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' kwds
        arg_ty d;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (d = kwds_rule(p))
        )
        {
            res = d;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_49: name_with_optional_default
static asdl_seq *
_loop1_49_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // name_with_optional_default
        NameDefaultPair* name_with_optional_default_var;
        while (
            (name_with_optional_default_var = name_with_optional_default_rule(p))
        )
        {
            res = name_with_optional_default_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_49");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_49_type, seq);
    return seq;
}

// _tmp_50: ',' kwds
static void *
_tmp_50_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' kwds
        arg_ty d;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (d = kwds_rule(p))
        )
        {
            res = d;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_51: '=' expression
static void *
_tmp_51_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '=' expression
        expr_ty e;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (e = expression_rule(p))
        )
        {
            res = e;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_53: ',' name_with_default
static asdl_seq *
_loop0_53_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' name_with_default
        NameDefaultPair* elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = name_with_default_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_53");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_53_type, seq);
    return seq;
}

// _gather_52: name_with_default _loop0_53
static asdl_seq *
_gather_52_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // name_with_default _loop0_53
        NameDefaultPair* elem;
        asdl_seq * seq;
        if (
            (elem = name_with_default_rule(p))
            &&
            (seq = _loop0_53_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_55: ',' (plain_name !'=')
static asdl_seq *
_loop0_55_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' (plain_name !'=')
        void *elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = _tmp_126_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_55");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_55_type, seq);
    return seq;
}

// _gather_54: (plain_name !'=') _loop0_55
static asdl_seq *
_gather_54_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // (plain_name !'=') _loop0_55
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_126_rule(p))
            &&
            (seq = _loop0_55_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_56: ':' annotation
static void *
_tmp_56_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ':' annotation
        void *literal;
        expr_ty z;
        if (
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (z = annotation_rule(p))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_57: ('@' named_expression NEWLINE)
static asdl_seq *
_loop1_57_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ('@' named_expression NEWLINE)
        void *_tmp_127_var;
        while (
            (_tmp_127_var = _tmp_127_rule(p))
        )
        {
            res = _tmp_127_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_57");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_57_type, seq);
    return seq;
}

// _tmp_58: '(' arguments? ')'
static void *
_tmp_58_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '(' arguments? ')'
        void *literal;
        void *literal_1;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 7))
            &&
            (z = arguments_rule(p), 1)
            &&
            (literal_1 = _PyPegen_expect_token(p, 8))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_60: ',' star_expression
static asdl_seq *
_loop0_60_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' star_expression
        expr_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = star_expression_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_60");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_60_type, seq);
    return seq;
}

// _gather_59: star_expression _loop0_60
static asdl_seq *
_gather_59_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // star_expression _loop0_60
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = star_expression_rule(p))
            &&
            (seq = _loop0_60_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_61: (',' star_expression)
static asdl_seq *
_loop1_61_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // (',' star_expression)
        void *_tmp_128_var;
        while (
            (_tmp_128_var = _tmp_128_rule(p))
        )
        {
            res = _tmp_128_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_61");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_61_type, seq);
    return seq;
}

// _loop0_63: ',' star_named_expression
static asdl_seq *
_loop0_63_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' star_named_expression
        expr_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = star_named_expression_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_63");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_63_type, seq);
    return seq;
}

// _gather_62: star_named_expression _loop0_63
static asdl_seq *
_gather_62_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // star_named_expression _loop0_63
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = star_named_expression_rule(p))
            &&
            (seq = _loop0_63_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_64: (',' expression)
static asdl_seq *
_loop1_64_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // (',' expression)
        void *_tmp_129_var;
        while (
            (_tmp_129_var = _tmp_129_rule(p))
        )
        {
            res = _tmp_129_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_64");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_64_type, seq);
    return seq;
}

// _tmp_65: ',' lambda_plain_names
static void *
_tmp_65_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_plain_names
        void *literal;
        asdl_seq* x;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (x = lambda_plain_names_rule(p))
        )
        {
            res = x;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_66: ',' lambda_names_with_default
static void *
_tmp_66_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_names_with_default
        void *literal;
        asdl_seq* y;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (y = lambda_names_with_default_rule(p))
        )
        {
            res = y;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_67: ',' lambda_star_etc?
static void *
_tmp_67_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_star_etc?
        void *literal;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = lambda_star_etc_rule(p), 1)
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_68: ',' lambda_names_with_default
static void *
_tmp_68_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_names_with_default
        void *literal;
        asdl_seq* y;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (y = lambda_names_with_default_rule(p))
        )
        {
            res = y;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_69: ',' lambda_star_etc?
static void *
_tmp_69_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_star_etc?
        void *literal;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = lambda_star_etc_rule(p), 1)
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_70: ',' lambda_names_with_default
static void *
_tmp_70_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_names_with_default
        void *literal;
        asdl_seq* y;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (y = lambda_names_with_default_rule(p))
        )
        {
            res = y;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_71: ',' lambda_star_etc?
static void *
_tmp_71_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_star_etc?
        void *literal;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = lambda_star_etc_rule(p), 1)
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_72: ',' lambda_star_etc?
static void *
_tmp_72_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_star_etc?
        void *literal;
        void *z;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = lambda_star_etc_rule(p), 1)
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_73: lambda_plain_names ','
static void *
_tmp_73_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // lambda_plain_names ','
        void *literal;
        asdl_seq* n;
        if (
            (n = lambda_plain_names_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
        )
        {
            res = n;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_74: lambda_name_with_optional_default
static asdl_seq *
_loop0_74_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // lambda_name_with_optional_default
        NameDefaultPair* lambda_name_with_optional_default_var;
        while (
            (lambda_name_with_optional_default_var = lambda_name_with_optional_default_rule(p))
        )
        {
            res = lambda_name_with_optional_default_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_74");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_74_type, seq);
    return seq;
}

// _tmp_75: ',' lambda_kwds
static void *
_tmp_75_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_kwds
        arg_ty d;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (d = lambda_kwds_rule(p))
        )
        {
            res = d;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_76: lambda_name_with_optional_default
static asdl_seq *
_loop1_76_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // lambda_name_with_optional_default
        NameDefaultPair* lambda_name_with_optional_default_var;
        while (
            (lambda_name_with_optional_default_var = lambda_name_with_optional_default_rule(p))
        )
        {
            res = lambda_name_with_optional_default_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_76");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_76_type, seq);
    return seq;
}

// _tmp_77: ',' lambda_kwds
static void *
_tmp_77_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' lambda_kwds
        arg_ty d;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (d = lambda_kwds_rule(p))
        )
        {
            res = d;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_78: '=' expression
static void *
_tmp_78_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '=' expression
        expr_ty e;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (e = expression_rule(p))
        )
        {
            res = e;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_80: ',' lambda_name_with_default
static asdl_seq *
_loop0_80_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' lambda_name_with_default
        NameDefaultPair* elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = lambda_name_with_default_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_80");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_80_type, seq);
    return seq;
}

// _gather_79: lambda_name_with_default _loop0_80
static asdl_seq *
_gather_79_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // lambda_name_with_default _loop0_80
        NameDefaultPair* elem;
        asdl_seq * seq;
        if (
            (elem = lambda_name_with_default_rule(p))
            &&
            (seq = _loop0_80_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_82: ',' (lambda_plain_name !'=')
static asdl_seq *
_loop0_82_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' (lambda_plain_name !'=')
        void *elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = _tmp_130_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_82");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_82_type, seq);
    return seq;
}

// _gather_81: (lambda_plain_name !'=') _loop0_82
static asdl_seq *
_gather_81_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // (lambda_plain_name !'=') _loop0_82
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_130_rule(p))
            &&
            (seq = _loop0_82_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_83: ('or' conjunction)
static asdl_seq *
_loop1_83_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ('or' conjunction)
        void *_tmp_131_var;
        while (
            (_tmp_131_var = _tmp_131_rule(p))
        )
        {
            res = _tmp_131_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_83");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_83_type, seq);
    return seq;
}

// _loop1_84: ('and' inversion)
static asdl_seq *
_loop1_84_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ('and' inversion)
        void *_tmp_132_var;
        while (
            (_tmp_132_var = _tmp_132_rule(p))
        )
        {
            res = _tmp_132_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_84");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_84_type, seq);
    return seq;
}

// _loop1_85: compare_op_bitwise_or_pair
static asdl_seq *
_loop1_85_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // compare_op_bitwise_or_pair
        CmpopExprPair* compare_op_bitwise_or_pair_var;
        while (
            (compare_op_bitwise_or_pair_var = compare_op_bitwise_or_pair_rule(p))
        )
        {
            res = compare_op_bitwise_or_pair_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_85");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_85_type, seq);
    return seq;
}

// _loop0_87: ',' slice
static asdl_seq *
_loop0_87_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' slice
        expr_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = slice_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_87");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_87_type, seq);
    return seq;
}

// _gather_86: slice _loop0_87
static asdl_seq *
_gather_86_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // slice _loop0_87
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = slice_rule(p))
            &&
            (seq = _loop0_87_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_88: ':' expression?
static void *
_tmp_88_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ':' expression?
        void *d;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 11))
            &&
            (d = expression_rule(p), 1)
        )
        {
            res = d;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_89: tuple | group | genexp
static void *
_tmp_89_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // tuple
        expr_ty tuple_var;
        if (
            (tuple_var = tuple_rule(p))
        )
        {
            res = tuple_var;
            goto done;
        }
        p->mark = mark;
    }
    { // group
        expr_ty group_var;
        if (
            (group_var = group_rule(p))
        )
        {
            res = group_var;
            goto done;
        }
        p->mark = mark;
    }
    { // genexp
        expr_ty genexp_var;
        if (
            (genexp_var = genexp_rule(p))
        )
        {
            res = genexp_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_90: list | listcomp
static void *
_tmp_90_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // list
        expr_ty list_var;
        if (
            (list_var = list_rule(p))
        )
        {
            res = list_var;
            goto done;
        }
        p->mark = mark;
    }
    { // listcomp
        expr_ty listcomp_var;
        if (
            (listcomp_var = listcomp_rule(p))
        )
        {
            res = listcomp_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_91: dict | set | dictcomp | setcomp
static void *
_tmp_91_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // dict
        expr_ty dict_var;
        if (
            (dict_var = dict_rule(p))
        )
        {
            res = dict_var;
            goto done;
        }
        p->mark = mark;
    }
    { // set
        expr_ty set_var;
        if (
            (set_var = set_rule(p))
        )
        {
            res = set_var;
            goto done;
        }
        p->mark = mark;
    }
    { // dictcomp
        expr_ty dictcomp_var;
        if (
            (dictcomp_var = dictcomp_rule(p))
        )
        {
            res = dictcomp_var;
            goto done;
        }
        p->mark = mark;
    }
    { // setcomp
        expr_ty setcomp_var;
        if (
            (setcomp_var = setcomp_rule(p))
        )
        {
            res = setcomp_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_92: STRING
static asdl_seq *
_loop1_92_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // STRING
        expr_ty string_var;
        while (
            (string_var = _PyPegen_string_token(p))
        )
        {
            res = string_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_92");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_92_type, seq);
    return seq;
}

// _tmp_93: star_named_expression ',' star_named_expressions?
static void *
_tmp_93_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // star_named_expression ',' star_named_expressions?
        void *literal;
        expr_ty y;
        void *z;
        if (
            (y = star_named_expression_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (z = star_named_expressions_rule(p), 1)
        )
        {
            res = _PyPegen_seq_insert_in_front ( p , y , z );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_94: yield_expr | named_expression
static void *
_tmp_94_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // yield_expr
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))
        )
        {
            res = yield_expr_var;
            goto done;
        }
        p->mark = mark;
    }
    { // named_expression
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))
        )
        {
            res = named_expression_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_96: ',' kvpair
static asdl_seq *
_loop0_96_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' kvpair
        KeyValuePair* elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = kvpair_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_96");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_96_type, seq);
    return seq;
}

// _gather_95: kvpair _loop0_96
static asdl_seq *
_gather_95_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // kvpair _loop0_96
        KeyValuePair* elem;
        asdl_seq * seq;
        if (
            (elem = kvpair_rule(p))
            &&
            (seq = _loop0_96_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop1_97: (ASYNC? 'for' star_targets 'in' disjunction (('if' disjunction))*)
static asdl_seq *
_loop1_97_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // (ASYNC? 'for' star_targets 'in' disjunction (('if' disjunction))*)
        void *_tmp_133_var;
        while (
            (_tmp_133_var = _tmp_133_rule(p))
        )
        {
            res = _tmp_133_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    if (n == 0) {
        PyMem_Free(children);
        return NULL;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_97");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop1_97_type, seq);
    return seq;
}

// _tmp_98: ',' args
static void *
_tmp_98_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' args
        expr_ty c;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (c = args_rule(p))
        )
        {
            res = c;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_99: ',' args
static void *
_tmp_99_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' args
        expr_ty c;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (c = args_rule(p))
        )
        {
            res = c;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_101: ',' kwarg_or_starred
static asdl_seq *
_loop0_101_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' kwarg_or_starred
        KeywordOrStarred* elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = kwarg_or_starred_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_101");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_101_type, seq);
    return seq;
}

// _gather_100: kwarg_or_starred _loop0_101
static asdl_seq *
_gather_100_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // kwarg_or_starred _loop0_101
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_starred_rule(p))
            &&
            (seq = _loop0_101_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_103: ',' kwarg_or_double_starred
static asdl_seq *
_loop0_103_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' kwarg_or_double_starred
        KeywordOrStarred* elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = kwarg_or_double_starred_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_103");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_103_type, seq);
    return seq;
}

// _gather_102: kwarg_or_double_starred _loop0_103
static asdl_seq *
_gather_102_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // kwarg_or_double_starred _loop0_103
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_double_starred_rule(p))
            &&
            (seq = _loop0_103_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_105: ',' kwarg_or_starred
static asdl_seq *
_loop0_105_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' kwarg_or_starred
        KeywordOrStarred* elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = kwarg_or_starred_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_105");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_105_type, seq);
    return seq;
}

// _gather_104: kwarg_or_starred _loop0_105
static asdl_seq *
_gather_104_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // kwarg_or_starred _loop0_105
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_starred_rule(p))
            &&
            (seq = _loop0_105_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_107: ',' kwarg_or_double_starred
static asdl_seq *
_loop0_107_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' kwarg_or_double_starred
        KeywordOrStarred* elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = kwarg_or_double_starred_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_107");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_107_type, seq);
    return seq;
}

// _gather_106: kwarg_or_double_starred _loop0_107
static asdl_seq *
_gather_106_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // kwarg_or_double_starred _loop0_107
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_double_starred_rule(p))
            &&
            (seq = _loop0_107_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_108: (',' star_target)
static asdl_seq *
_loop0_108_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // (',' star_target)
        void *_tmp_134_var;
        while (
            (_tmp_134_var = _tmp_134_rule(p))
        )
        {
            res = _tmp_134_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_108");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_108_type, seq);
    return seq;
}

// _loop0_110: ',' star_target
static asdl_seq *
_loop0_110_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' star_target
        expr_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = star_target_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_110");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_110_type, seq);
    return seq;
}

// _gather_109: star_target _loop0_110
static asdl_seq *
_gather_109_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // star_target _loop0_110
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = star_target_rule(p))
            &&
            (seq = _loop0_110_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_111: !'*' star_target
static void *
_tmp_111_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // !'*' star_target
        expr_ty star_target_var;
        if (
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 16)
            &&
            (star_target_var = star_target_rule(p))
        )
        {
            res = star_target_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_113: ',' del_target
static asdl_seq *
_loop0_113_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' del_target
        expr_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = del_target_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_113");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_113_type, seq);
    return seq;
}

// _gather_112: del_target _loop0_113
static asdl_seq *
_gather_112_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // del_target _loop0_113
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = del_target_rule(p))
            &&
            (seq = _loop0_113_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_115: ',' target
static asdl_seq *
_loop0_115_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ',' target
        expr_ty elem;
        void *literal;
        while (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (elem = target_rule(p))
        )
        {
            res = elem;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(children);
                return NULL;
            }
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_115");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_115_type, seq);
    return seq;
}

// _gather_114: target _loop0_115
static asdl_seq *
_gather_114_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    asdl_seq * res = NULL;
    int mark = p->mark;
    { // target _loop0_115
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = target_rule(p))
            &&
            (seq = _loop0_115_rule(p))
        )
        {
            res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_116: args | expression for_if_clauses
static void *
_tmp_116_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // args
        expr_ty args_var;
        if (
            (args_var = args_rule(p))
        )
        {
            res = args_var;
            goto done;
        }
        p->mark = mark;
    }
    { // expression for_if_clauses
        expr_ty expression_var;
        asdl_seq* for_if_clauses_var;
        if (
            (expression_var = expression_rule(p))
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))
        )
        {
            res = _PyPegen_dummy_name(p, expression_var, for_if_clauses_var);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_117: '=' annotated_rhs
static void *
_tmp_117_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '=' annotated_rhs
        expr_ty annotated_rhs_var;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 22))
            &&
            (annotated_rhs_var = annotated_rhs_rule(p))
        )
        {
            res = _PyPegen_dummy_name(p, literal, annotated_rhs_var);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_118: '=' | augassign
static void *
_tmp_118_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '='
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 22))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    { // augassign
        AugOperator* augassign_var;
        if (
            (augassign_var = augassign_rule(p))
        )
        {
            res = augassign_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_119: yield_expr | star_expressions
static void *
_tmp_119_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // yield_expr
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))
        )
        {
            res = yield_expr_var;
            goto done;
        }
        p->mark = mark;
    }
    { // star_expressions
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))
        )
        {
            res = star_expressions_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_120: '[' | '(' | '{'
static void *
_tmp_120_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '['
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 9))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    { // '('
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 7))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    { // '{'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 25))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_121: plain_names ','
static void *
_tmp_121_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // plain_names ','
        void *literal;
        asdl_seq* plain_names_var;
        if (
            (plain_names_var = plain_names_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 12))
        )
        {
            res = _PyPegen_dummy_name(p, plain_names_var, literal);
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_122: slash_with_default | names_with_default
static void *
_tmp_122_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // slash_with_default
        SlashWithDefault* slash_with_default_var;
        if (
            (slash_with_default_var = slash_with_default_rule(p))
        )
        {
            res = slash_with_default_var;
            goto done;
        }
        p->mark = mark;
    }
    { // names_with_default
        asdl_seq* names_with_default_var;
        if (
            (names_with_default_var = names_with_default_rule(p))
        )
        {
            res = names_with_default_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_123: star_targets '='
static void *
_tmp_123_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // star_targets '='
        void *literal;
        expr_ty z;
        if (
            (z = star_targets_rule(p))
            &&
            (literal = _PyPegen_expect_token(p, 22))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_124: '.' | '...'
static void *
_tmp_124_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '.'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 23))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    { // '...'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 52))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_125: '.' | '...'
static void *
_tmp_125_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '.'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 23))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    { // '...'
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 52))
        )
        {
            res = literal;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_126: plain_name !'='
static void *
_tmp_126_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // plain_name !'='
        arg_ty plain_name_var;
        if (
            (plain_name_var = plain_name_rule(p))
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)
        )
        {
            res = plain_name_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_127: '@' named_expression NEWLINE
static void *
_tmp_127_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // '@' named_expression NEWLINE
        expr_ty f;
        void *literal;
        void *newline_var;
        if (
            (literal = _PyPegen_expect_token(p, 49))
            &&
            (f = named_expression_rule(p))
            &&
            (newline_var = _PyPegen_newline_token(p))
        )
        {
            res = f;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_128: ',' star_expression
static void *
_tmp_128_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' star_expression
        expr_ty c;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (c = star_expression_rule(p))
        )
        {
            res = c;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_129: ',' expression
static void *
_tmp_129_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' expression
        expr_ty c;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (c = expression_rule(p))
        )
        {
            res = c;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_130: lambda_plain_name !'='
static void *
_tmp_130_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // lambda_plain_name !'='
        arg_ty lambda_plain_name_var;
        if (
            (lambda_plain_name_var = lambda_plain_name_rule(p))
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)
        )
        {
            res = lambda_plain_name_var;
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_131: 'or' conjunction
static void *
_tmp_131_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'or' conjunction
        expr_ty c;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 532))
            &&
            (c = conjunction_rule(p))
        )
        {
            res = c;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_132: 'and' inversion
static void *
_tmp_132_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'and' inversion
        expr_ty c;
        void *keyword;
        if (
            (keyword = _PyPegen_expect_token(p, 533))
            &&
            (c = inversion_rule(p))
        )
        {
            res = c;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_133: ASYNC? 'for' star_targets 'in' disjunction (('if' disjunction))*
static void *
_tmp_133_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ASYNC? 'for' star_targets 'in' disjunction (('if' disjunction))*
        expr_ty a;
        expr_ty b;
        asdl_seq * c;
        void *keyword;
        void *keyword_1;
        void *y;
        if (
            (y = _PyPegen_async_token(p), 1)
            &&
            (keyword = _PyPegen_expect_token(p, 517))
            &&
            (a = star_targets_rule(p))
            &&
            (keyword_1 = _PyPegen_expect_token(p, 518))
            &&
            (b = disjunction_rule(p))
            &&
            (c = _loop0_135_rule(p))
        )
        {
            res = _Py_comprehension ( a , b , c , y != NULL , p -> arena );
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _tmp_134: ',' star_target
static void *
_tmp_134_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // ',' star_target
        expr_ty c;
        void *literal;
        if (
            (literal = _PyPegen_expect_token(p, 12))
            &&
            (c = star_target_rule(p))
        )
        {
            res = c;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

// _loop0_135: ('if' disjunction)
static asdl_seq *
_loop0_135_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void *res = NULL;
    int mark = p->mark;
    int start_mark = p->mark;
    void **children = PyMem_Malloc(sizeof(void *));
    if (!children) {
        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
        return NULL;
    }
    ssize_t children_capacity = 1;
    ssize_t n = 0;
    { // ('if' disjunction)
        void *_tmp_136_var;
        while (
            (_tmp_136_var = _tmp_136_rule(p))
        )
        {
            res = _tmp_136_var;
            if (n == children_capacity) {
                children_capacity *= 2;
                children = PyMem_Realloc(children, children_capacity*sizeof(void *));
                if (!children) {
                    PyErr_Format(PyExc_MemoryError, "realloc None");
                    return NULL;
                }
            }
            children[n++] = res;
            mark = p->mark;
        }
        p->mark = mark;
    }
    asdl_seq *seq = _Py_asdl_seq_new(n, p->arena);
    if (!seq) {
        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_135");
        PyMem_Free(children);
        return NULL;
    }
    for (int i = 0; i < n; i++) asdl_seq_SET(seq, i, children[i]);
    PyMem_Free(children);
    _PyPegen_insert_memo(p, start_mark, _loop0_135_type, seq);
    return seq;
}

// _tmp_136: 'if' disjunction
static void *
_tmp_136_rule(Parser *p)
{
    if (p->error_indicator) {
        return NULL;
    }
    void * res = NULL;
    int mark = p->mark;
    { // 'if' disjunction
        void *keyword;
        expr_ty z;
        if (
            (keyword = _PyPegen_expect_token(p, 510))
            &&
            (z = disjunction_rule(p))
        )
        {
            res = z;
            if (res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                return NULL;
            }
            goto done;
        }
        p->mark = mark;
    }
    res = NULL;
  done:
    return res;
}

void *
_PyPegen_parse(Parser *p)
{
    // Initialize keywords
    p->keywords = reserved_keywords;
    p->n_keyword_lists = n_keyword_lists;

    // Run parser
    void *result = NULL;
    if (p->start_rule == Py_file_input) {
        result = file_rule(p);
    } else if (p->start_rule == Py_single_input) {
        result = interactive_rule(p);
    } else if (p->start_rule == Py_eval_input) {
        result = eval_rule(p);
    } else if (p->start_rule == Py_fstring_input) {
        result = fstring_rule(p);
    }

    return result;
}

// The end
